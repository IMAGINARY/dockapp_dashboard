{"version":3,"sources":["cli/dockapp-cli.js"],"names":["http","require","hostname","port","listStations","request","method","path","res","body","on","chunk","setEncoding","response","JSON","parse","stations","station","console","log","id","end","startStation","stationID","postData","stringify","ids","req","headers","Buffer","byteLength","write"],"mappings":";;AAAA,IAAMA,OAAOC,QAAQ,MAAR,CAAb;;AAEA,IAAMC,WAAW,WAAjB;AACA,IAAMC,OAAO,IAAb;;AAEA,SAASC,YAAT,GAAwB;AACtBJ,OAAKK,OAAL,CAAa;AACXH,sBADW;AAEXC,cAFW;AAGXG,YAAQ,KAHG;AAIXC,UAAM;AAJK,GAAb,EAMA,UAACC,GAAD,EAAS;AACP,QAAIC,OAAO,EAAX;AACAD,QAAIE,EAAJ,CAAO,MAAP,EAAe,UAACC,KAAD,EAAW;AACxBF,cAAQE,KAAR;AACD,KAFD;AAGAH,QAAIE,EAAJ,CAAO,KAAP,EAAc,YAAM;AAClBF,UAAII,WAAJ,CAAgB,MAAhB;AACA,UAAMC,WAAWC,KAAKC,KAAL,CAAWN,IAAX,CAAjB;AAFkB;AAAA;AAAA;;AAAA;AAGlB,6BAAsBI,SAASG,QAA/B,8HAAyC;AAAA,cAA9BC,OAA8B;;AACvCC,kBAAQC,GAAR,CAAYF,QAAQG,EAApB;AACD;AALiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMnB,KAND;AAOD,GAlBD,EAkBGC,GAlBH;AAmBD;;AAED,SAASC,YAAT,CAAsBC,SAAtB,EAAiC;AAC/B,MAAMC,WAAWV,KAAKW,SAAL,CAAe;AAC9BC,SAAK,CAACH,SAAD;AADyB,GAAf,CAAjB;;AAIA,MAAMI,MAAM3B,KAAKK,OAAL,CAAa;AACvBH,sBADuB;AAEvBC,cAFuB;AAGvBG,YAAQ,MAHe;AAIvBC,UAAM,qBAJiB;AAKvBqB,aAAS;AACP,sBAAgB,kBADT;AAEP,wBAAkBC,OAAOC,UAAP,CAAkBN,QAAlB;AAFX;AALc,GAAb,EAUZ,UAAChB,GAAD,EAAS;AACPA,QAAII,WAAJ,CAAgB,MAAhB;AACA,QAAIH,OAAO,EAAX;AACAD,QAAIE,EAAJ,CAAO,MAAP,EAAe,UAACC,KAAD,EAAW;AACxBF,cAAQE,KAAR;AACD,KAFD;AAGAH,QAAIE,EAAJ,CAAO,KAAP,EAAc,YAAM,CAEnB,CAFD;AAGD,GAnBW,CAAZ;;AAqBAiB,MAAII,KAAJ,CAAUP,QAAV;AACAG,MAAIN,GAAJ;;AAEAH,UAAQC,GAAR,uBAAgCI,SAAhC;AACD;;AAEDnB;AACAkB,aAAa,uBAAb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"cli/dockapp-cli.js","sourcesContent":["const http = require('http');\n\nconst hostname = 'localhost';\nconst port = 8080;\n\nfunction listStations() {\n  http.request({\n    hostname,\n    port,\n    method: 'GET',\n    path: '/api/stations',\n  },\n  (res) => {\n    let body = '';\n    res.on('data', (chunk) => {\n      body += chunk;\n    });\n    res.on('end', () => {\n      res.setEncoding('utf8');\n      const response = JSON.parse(body);\n      for (const station of response.stations) {\n        console.log(station.id);\n      }\n    });\n  }).end();\n}\n\nfunction startStation(stationID) {\n  const postData = JSON.stringify({\n    ids: [stationID],\n  });\n\n  const req = http.request({\n    hostname,\n    port,\n    method: 'POST',\n    path: '/api/stations/start',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': Buffer.byteLength(postData),\n    },\n  },\n  (res) => {\n    res.setEncoding('utf8');\n    let body = '';\n    res.on('data', (chunk) => {\n      body += chunk;\n    });\n    res.on('end', () => {\n\n    });\n  });\n\n  req.write(postData);\n  req.end();\n\n  console.log(`Starting station ${stationID}`);\n}\n\nlistStations();\nstartStation('station_interactive_1');\n\n// Interface\n// listStations\n//   - as list of IDs\n//   - as table (id, name, app)\n// startStations (<list of stations>)\n//   - if all, confirm\n//   - -y overrides confirmation\n//   - --wait // waits until done (might not be possible *1)\n// stopStations (<list of stations>)\n//   - if all, confirm\n//   - -y overrides confirmation\n//   - --wait // waits until done (might not be possible *1)\n// availableApps <station>\n//   - prints list of applications for station\n// changeApp <appID> <stations>\n//   - Changes the app of stations to the indicated one\n//   - --wait // waits until done (might not be possible *1)\n//\n// *1 - To wait it's necessary to poll the state of the stations but:\n//      a - I would have to determine which stations CAN be started/stopped\n//      b - They might never reach the desired state for reasons beyond my control\n//\n// I still need:\n// - Richer responses on the back end (when it's not possible to start/stop/change a station)\n"],"sourceRoot":"/source/"}