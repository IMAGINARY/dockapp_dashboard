{"version":3,"sources":["lib/dockapp-connector.js"],"names":[],"mappings":"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","file":"lib/dockapp-connector.js","sourcesContent":["const Promise = require('bluebird');\nconst exec = require('child_process').exec;\n\n/**\n * Interface with DockApp via scripts\n *\n * This class doesn't check the state of the stations before dispatching\n * the commands.\n */\nexport default class DockAppConnector {\n\n  constructor(nconf, logger) {\n    this.nconf = nconf;\n    this.logger = logger;\n  }\n\n  /**\n   * Reads the station config\n   * @param {TerminalOutputBuffer} output\n   * @returns {Promise}\n   * @resolve {Array} - List of stations\n   * @reject {Error}\n   */\n  getStationConfig(output) {\n    this.logger.verbose('DockApp: Getting station config');\n    return new Promise((resolve, reject) => {\n      this.execute(DockAppConnector.SCRIPT_LIST_STATIONS, output)\n        .then((answer) => {\n          this.logger.debug(`DockApp: Station config read:\n${answer}`);\n          const stationCfg = JSON.parse(answer);\n          if (!stationCfg instanceof Array) {\n            throw new Error(`Dockapp returned an invalid station config: ${answer}`);\n          }\n          if (stationCfg.length === 0) {\n            throw new Error('Dockapp returned an empty station config.');\n          }\n          resolve(stationCfg);\n        })\n        .catch((err) => {\n          this.logger.error(`DockApp: Error getting station config '${err.message}'`);\n          reject(err);\n        });\n    });\n  }\n\n  /**\n   * Start a station\n   * @param {string} stationID - ID of the station\n   * @param {stream} output - Command output should be written here\n   * @returns Promise\n   */\n  startStation(stationID, output) {\n    this.logger.verbose(`DockApp: Starting station ${stationID}`);\n    return new Promise((resolve, reject) => {\n      this.execute(`${DockAppConnector.SCRIPT_START_STATION} ${stationID}`, output)\n        .then(() => {\n          resolve();\n        })\n        .catch((err) => {\n          this.logger.error(`DockApp: Error starting station ${stationID}, '${err.message}'`);\n          reject(err);\n        });\n    });\n  }\n\n  /**\n   * Stop a station\n   * @param {string} stationID - ID of the station\n   * @param {stream} output - Command output should be written here\n   * @returns Promise\n   */\n  stopStation(stationID, output) {\n    this.logger.verbose(`DockApp: Stopping station ${stationID}`);\n    return new Promise((resolve, reject) => {\n      this.execute(`${DockAppConnector.SCRIPT_STOP_STATION} ${stationID}`, output)\n        .then(() => {\n          resolve();\n        })\n        .catch((err) => {\n          this.logger.error(`DockApp: Error stopping station ${stationID}, '${err.message}'`);\n          reject(err);\n        });\n    });\n  }\n\n  /**\n   * Change the foreground application running in a station\n   * @param {string} stationID - ID of the station\n   * @param {string} appID - ID of the app to set\n   * @param {stream} output - Command output should be written here\n   * @returns {Promise}\n   */\n  changeApp(stationID, appID, output) {\n    this.logger.verbose(`DockApp: Changing app of station ${stationID} to ${appID}`);\n    return new Promise((resolve, reject) => {\n      this.execute(`${DockAppConnector.SCRIPT_CHANGE_APP} ${stationID} ${appID}`, output)\n        .then(() => {\n          resolve();\n        })\n        .catch((err) => {\n          this.logger.error(\n            `DockApp: Error changing station ${stationID} to app ${appID}, '${err.message}'`);\n          reject(err);\n        });\n    });\n  }\n\n  /**\n   * Executes a child process\n   * @private\n   *\n   * @param {string} command - Command to execute\n   * @param {stream} output - Command output should be written here\n   * @param {object} options - Options to pass child_process.exec\n   * @returns {Promise}\n   * @resolve {String} - stdout output\n   * @reject {Error}\n   */\n  execute(command, output, options) {\n    return new Promise((resolve, reject) => {\n      let stdoutBuf = '';\n      let alloutBuf = '';\n      this.logger.verbose(`Executing '${command}'`);\n\n      const execOptions = Object.assign({}, options); // clone\n\n      if (!execOptions.hasOwnProperty('env')) {\n        execOptions.env = {};\n      }\n      if (!execOptions.env.hasOwnProperty('DOCKAPP_PATH')) {\n        execOptions.env.DOCKAPP_PATH = this.nconf.get('dockapp_path');\n      }\n\n      const process = exec(command, execOptions);\n      process.stdout.on('data', (data) => {\n        stdoutBuf += data;\n        alloutBuf += data;\n        output.write(data);\n      });\n      process.stderr.on('data', (data) => {\n        alloutBuf += data;\n        output.write(data);\n      });\n      process.on('close', (code, signal) => {\n        if (code === 0) {\n          this.logger.verbose(`Execution of ${command} finished with code 0 (success).`);\n          resolve(stdoutBuf);\n        } else {\n          let term = `rc=${code}`;\n          if (signal !== null) {\n            term = `${term}, ${signal}`;\n          }\n          this.logger.error(`Execution of ${command} finished with ${term}.`);\n          this.logger.verbose('Output:');\n          this.logger.verbose(alloutBuf);\n          reject(new Error(`Command '${command}' exited with ${term}. ${alloutBuf}`));\n        }\n      });\n    });\n  }\n}\n\nDockAppConnector.SCRIPT_LIST_STATIONS = './scripts/list_stations.sh';\nDockAppConnector.SCRIPT_START_STATION = './scripts/start_station.sh';\nDockAppConnector.SCRIPT_STOP_STATION = './scripts/stop_station.sh';\nDockAppConnector.SCRIPT_CHANGE_APP = './scripts/appchange_station.sh';\n"],"sourceRoot":"/source/"}