// Compiled by Babel
// ** DO NOT EDIT THIS FILE DIRECTLY **
//
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _terminalOutputBuffer = require('./terminal-output-buffer');

var _terminalOutputBuffer2 = _interopRequireDefault(_terminalOutputBuffer);

var _nagios = require('./nagios');

var _nagios2 = _interopRequireDefault(_nagios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventEmitter = require('events').EventEmitter;

var Station = function () {
  function Station(id, config, nconf) {
    _classCallCheck(this, Station);

    this.nconf = nconf;

    this.id = id;
    this.name = config.name || id;
    this.description = config.description || '';
    this.profile = config.profile || '';
    this.type = config.type || '';
    this.default_app = config.client_settings && config.client_settings.hilbert_station_default_application || '';
    this.compatible_apps = config.compatible_applications;

    this.state = Station.UNKNOWN;
    this.setStatus('');
    this.app = '';
    this.switching_app = '';
    this.outputBuffer = new _terminalOutputBuffer2.default();
    this.events = new EventEmitter();
    this.transitionTimeout = null;
    this.onTransitionTimeout = this.onTransitionTimeout.bind(this);

    this.errorLockTimeout = null;
    this.errorLockStartTime = null;
  }

  _createClass(Station, [{
    key: 'toJSON',
    value: function toJSON() {
      return {
        id: this.id,
        name: this.name,
        description: this.description,
        profile: this.profile,
        type: this.type,
        state: this.state,
        app: this.app,
        status: this.status,
        locked: this.isErrorLocked(),
        locked_seconds: this.errorLockRemainingSeconds(),
        default_app: this.default_app,
        compatible_apps: this.compatible_apps,
        switching_app: this.switching_app
      };
    }

    /**
     * Updates the state of the station
     *
     * Returns true if the state was changed
     *
     * @param {Object} stationStatus - MKLivestatus status of the station
     * @param {String} stationStatus.id - station.id
     * @param {Number} stationStatus.state - Enum from Nagios.HostState
     * @param {Number} stationStatus.state_type - Enum from Nagios.StateType
     * @param {Number} stationStatus.app_state - Enum from Nagios.ServiceState
     * @param {Number} stationStatus.app_state_type - Enum from Nagios.StateType
     * @param {String} stationStatus.app_id - ID of the app
     * @returns {boolean}
     */

  }, {
    key: 'updateFromMKLivestatus',
    value: function updateFromMKLivestatus(stationStatus) {
      var changes = false;
      if (this.app !== stationStatus.app_id) {
        this.app = stationStatus.app_id;
        changes = true;
      }

      if (this.state === Station.ERROR && this.isErrorLocked()) {
        return false;
      }

      if (this.state !== Station.ERROR && stationStatus.state === _nagios2.default.HostState.UNREACHABLE) {
        this.setErrorState('Station unreachable');
        this.events.emit('stateChange', this, 'error', 'Station unreachable');
        return true;
      }

      if (this.state === Station.ERROR || this.state === Station.UNKNOWN) {
        if (stationStatus.state === _nagios2.default.HostState.DOWN) {
          this.setOffState();
          return true;
        } else if (stationStatus.state === _nagios2.default.HostState.UP) {
          this.setOnState();
          return true;
        }
      } else if (this.state === Station.ON) {
        if (stationStatus.state === _nagios2.default.HostState.DOWN) {
          this.setOffState('Unexpected stop');
          this.events.emit('stateChange', this, 'warning', 'Station stopped unexpectedly');
          return true;
        }
      } else if (this.state === Station.OFF) {
        if (stationStatus.state === _nagios2.default.HostState.UP) {
          this.setOnState();
          return true;
        }
      } else if (this.state === Station.STOPPING) {
        if (stationStatus.state === _nagios2.default.HostState.DOWN) {
          this.events.emit('stateChange', this, 'info', 'Station stopped');
          this.setOffState('Manually turned off');
          return true;
        }
      } else if (this.state === Station.STARTING_STATION) {
        if (stationStatus.state === _nagios2.default.HostState.UP) {
          this.setStartingAppState();
          return true;
        }
      } else if (this.state === Station.STARTING_APP) {
        if (stationStatus.state === _nagios2.default.HostState.DOWN) {
          this.setErrorState('Unexpected stop starting app. Please wait...');
          this.events.emit('stateChange', this, 'warning', 'Station stopped while starting app');
          this.errorLock();
          return true;
        }
        if (stationStatus.app_state === _nagios2.default.ServiceState.OK) {
          this.events.emit('stateChange', this, 'info', 'Station started');
          this.setOnState();
          return true;
        }
      } else if (this.state === Station.SWITCHING_APP) {
        if (stationStatus.state === _nagios2.default.HostState.DOWN) {
          this.setErrorState('Unexpected stop changing app. Please wait...');
          this.events.emit('stateChange', this, 'warning', 'Station stopped while changing app');
          this.errorLock();
          return true;
        }
        if (this.switching_app !== '' && this.switching_app === stationStatus.app_id) {
          this.events.emit('stateChange', this, 'info', 'App changed');
          this.setOnState();
          return true;
        }
      }

      return changes;
    }

    /**
     * Transitions the station to the "waiting to start" state
     *
     * @return {boolean} The transition was successful
     */

  }, {
    key: 'setQueuedToStartState',
    value: function setQueuedToStartState() {
      if (!this.isErrorLocked() && this.state === Station.OFF) {
        this.state = Station.STARTING_STATION;
        this.setStatus('Waiting to start...');
        this.startTransitionTimeout();
        return true;
      }
      return false;
    }

    /**
     * Transitions the station to the "starting" state
     *
     * @return {boolean} The transition was successful
     */

  }, {
    key: 'setStartingState',
    value: function setStartingState() {
      if (this.state === Station.OFF || this.state === Station.STARTING_STATION) {
        this.state = Station.STARTING_STATION;
        this.setStatus('Starting...');
        this.startTransitionTimeout();
        return true;
      }
      return false;
    }

    /**
     * Transitions the station to the "starting app" state
     *
     * @return {boolean} The transition was sucessful
     */

  }, {
    key: 'setStartingAppState',
    value: function setStartingAppState() {
      if (this.state === Station.STARTING_STATION) {
        this.state = Station.STARTING_APP;
        this.setStatus('Waiting for app...');
        this.startTransitionTimeout();
        return true;
      }
      return false;
    }

    /**
     * Transitions the station to the "waiting to stop" state
     *
     * @return {boolean} The transition was succesful
     */

  }, {
    key: 'setQueuedToStopState',
    value: function setQueuedToStopState() {
      if (!this.isErrorLocked() && this.state === Station.ON) {
        this.state = Station.STOPPING;
        this.setStatus('Waiting to stop...');
        this.startTransitionTimeout();
        return true;
      }
      return false;
    }

    /**
     * Transitions the station to the "stopping" state
     *
     * @return {boolean} The transition was successful
     */

  }, {
    key: 'setStoppingState',
    value: function setStoppingState() {
      if (this.state === Station.OFF || this.state === Station.STOPPING) {
        this.state = Station.STOPPING;
        this.setStatus('Stopping...');
        this.startTransitionTimeout();
        return true;
      }
      return false;
    }

    /**
     * Transitions the station to the "queued to change app" state
     *
     * @param appID {string}
     * @return {boolean} The transition was successful
     */

  }, {
    key: 'setQueuedToChangeAppState',
    value: function setQueuedToChangeAppState(appID) {
      if (!this.isErrorLocked() && this.state === Station.ON && appID !== this.app) {
        this.state = Station.SWITCHING_APP;
        this.setStatus('Waiting to change app...');
        this.switching_app = appID;
        this.startTransitionTimeout();
        return true;
      }
      return false;
    }

    /**
     * Transitions the station to the "changing app" state
     *
     * @param appID {string}
     * @return {boolean} The transition was successful
     */

  }, {
    key: 'setChangingAppState',
    value: function setChangingAppState(appID) {
      if ((this.state === Station.ON || this.state === Station.SWITCHING_APP) && appID !== this.app) {
        this.state = Station.SWITCHING_APP;
        this.setStatus('Opening ' + appID + '...');
        this.switching_app = appID;
        this.startTransitionTimeout();
        return true;
      }
      return false;
    }
  }, {
    key: 'setOnState',
    value: function setOnState() {
      this.state = Station.ON;
      this.setStatus('');
      this.switching_app = '';
      this.clearTransitionTimeout();
    }
  }, {
    key: 'setOffState',
    value: function setOffState() {
      var reason = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

      this.state = Station.OFF;
      this.setStatus(reason, reason !== '');
      this.switching_app = '';
      this.clearTransitionTimeout();
    }

    /**
     * Transitions the station to the "error" state
     *
     * @param reason {string} Description of the error
     */

  }, {
    key: 'setErrorState',
    value: function setErrorState(reason) {
      this.state = Station.ERROR;
      this.setStatus(reason);
      this.clearTransitionTimeout();
    }

    /**
     * Sets the station status text
     *
     * @private
     * @param text {String} Status text
     * @param withTimestamp {Boolean} Add a timestamp to the status
     */

  }, {
    key: 'setStatus',
    value: function setStatus(text) {
      var withTimestamp = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      var timestamp = '';
      if (withTimestamp) {
        var now = new Date();
        timestamp = now.getDate() + '/' + now.getMonth() + ' ' + now.getHours() + ':' + now.getMinutes();
      }

      this.status = [text, timestamp].join(' ');
    }

    /**
     * Start checking for a timeout while waiting for an operation to complete
     */

  }, {
    key: 'startTransitionTimeout',
    value: function startTransitionTimeout() {
      if (this.transitionTimeout !== null) {
        this.clearTransitionTimeout();
      }

      this.transitionTimeout = setTimeout(this.onTransitionTimeout, this.nconf.get('operation_timeout') * 1000);
    }

    /**
     * Clear checking for a timeout waiting for an operation to complete
     */

  }, {
    key: 'clearTransitionTimeout',
    value: function clearTransitionTimeout() {
      clearTimeout(this.transitionTimeout);
      this.transitionTimeout = null;
    }

    /**
     * Event handler for timeouts waiting for an operation to complete
     */

  }, {
    key: 'onTransitionTimeout',
    value: function onTransitionTimeout() {
      this.transitionTimeout = null;

      var messages = {};
      messages[Station.STARTING_STATION] = 'Time out waiting for station to start';
      messages[Station.STARTING_APP] = 'Time out waiting for app to start';
      messages[Station.SWITCHING_APP] = 'Time out waiting for app to change';
      messages[Station.STOPPING] = 'Time out waiting for station to stop';
      this.events.emit('stateChange', this, 'error', messages[this.state] || 'Operation timed out');

      this.state = Station.UNKNOWN;
    }

    /**
     * Locks the station for a number of seconds after an error
     *
     * While the station is locked no operations (stop, start, change app) can be started.
     */

  }, {
    key: 'errorLock',
    value: function errorLock() {
      var _this = this;

      this.clearErrorLock();

      this.errorLockStartTime = Date.now();
      this.errorLockTimeout = setTimeout(function () {
        _this.errorLockTimeout = null;
        _this.errorLockStartTime = null;
      }, this.nconf.get('error_lock_time') * 1000);
    }

    /**
     * Pre-empts an error lock
     *
     * The station is unlocked immediately and its error lock timer is cleared.
     */

  }, {
    key: 'clearErrorLock',
    value: function clearErrorLock() {
      if (this.errorLockTimeout !== null) {
        clearTimeout(this.errorLockTimeout);
        this.errorLockTimeout = null;
        this.errorLockStartTime = null;
      }
    }

    /**
     * True if the station is locked because of an error
     */

  }, {
    key: 'isErrorLocked',
    value: function isErrorLocked() {
      return this.errorLockTimeout !== null;
    }

    /**
     * Returns the number of seconds remaining before the error lock will end
     *
     * @return {number}
     */

  }, {
    key: 'errorLockRemainingSeconds',
    value: function errorLockRemainingSeconds() {
      if (this.errorLockTimeout === null || this.errorLockStartTime === null) {
        return 0;
      }

      var elapsedSeconds = Math.floor((Date.now() - this.errorLockStartTime) / 1000);
      var wait = this.nconf.get('error_lock_time') || 0;

      return Math.max(wait - elapsedSeconds, 0);
    }
  }]);

  return Station;
}();

// Station states

exports.default = Station;
Station.UNKNOWN = 'unk';
Station.OFF = 'off';
Station.ON = 'on';
Station.STOPPING = 'stopping';
Station.STARTING_STATION = 'starting_station';
Station.STARTING_APP = 'starting_app';
Station.SWITCHING_APP = 'switching_app';
Station.ERROR = 'error';
//# sourceMappingURL=station.js.map
