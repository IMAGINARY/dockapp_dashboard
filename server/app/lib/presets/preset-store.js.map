{"version":3,"sources":["lib/presets/preset-store.js"],"names":["sqlite3","require","Promise","PresetStore","db","filename","resolve","reject","Database","OPEN_READWRITE","OPEN_CREATE","err","then","tableExists","exists","createTables","close","get","$table","row","undefined","run","data","answer","setStore","all","rows","push","createPreset","id","name","stationApps","JSON","parse","$id","preset","$name","$stationApps","stringify","callback","lastID","checkDuplicateNameError","errno"],"mappings":"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","file":"lib/presets/preset-store.js","sourcesContent":["import Preset from './preset';\nimport DuplicateIdentifierError from './duplicate-identifier-error';\n\nconst sqlite3 = require('sqlite3');\nconst Promise = require('bluebird');\n\n/**\n * Manages Preset persistant storage\n */\nexport default class PresetStore {\n\n  constructor() {\n    this.db = null;\n  }\n\n  /**\n   * Opens the store database and inits it if needed\n   *\n   * After opening the database checks if the tables exist and creates them if they don't.\n   *\n   * @param filename\n   *   Filename of the database file or ':memory:' for an anonymous in-memory database\n   *   or an empty string for an anonymous disk-based database.\n   *\n   * @return {Promise}\n   */\n  open(filename) {\n    return new Promise((resolve, reject) => {\n      this.db = new sqlite3.Database(\n        filename,\n        sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, // eslint-disable-line no-bitwise\n        (err) => {\n          if (err === null) {\n            resolve();\n          } else {\n            reject(err);\n          }\n        });\n    })\n    .then(() => this.tableExists())\n    .then((exists) => {\n      if (!exists) {\n        return this.createTables();\n      }\n      return Promise.resolve();\n    });\n  }\n\n  /**\n   * Closes the database\n   *\n   * @return {Promise}\n   */\n  close() {\n    return new Promise((resolve, reject) => {\n      this.db.close((err) => {\n        if (err === null) {\n          this.db = null;\n          resolve();\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n\n  /**\n   * Checks if the storage table exists in the database\n   *\n   * @return {Ì¦Promise}\n   *  The promise resolves to a bool with the answer\n   */\n  tableExists() {\n    return new Promise((resolve, reject) => {\n      this.db.get(\"SELECT name FROM sqlite_master WHERE type='table' AND name=$table;\",\n        { $table: 'presets' },\n        (err, row) => {\n          if (err === null) {\n            resolve(row !== undefined);\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Creates the storage tables in the database\n   *\n   * @return {Promise}\n   */\n  createTables() {\n    return new Promise((resolve, reject) => {\n      this.db.run(`\nCREATE TABLE IF NOT EXISTS presets \n(\n  id integer PRIMARY KEY NOT NULL,\n  name text UNIQUE, \n  stationApps text\n)\n`,\n        [],\n        (err) => {\n          if (err === null) {\n            resolve();\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Creates a Preset object associated to this store\n   *\n   * @param {Object} data\n   *  Data properties to initialize the preset\n   * @return {Preset}\n   */\n  createPreset(data = {}) {\n    const answer = new Preset(data);\n    answer.setStore(this);\n    return answer;\n  }\n\n  /**\n   * Loads all presets\n   *\n   * @return {Promise<Array<Preset>>}\n   */\n  loadAllPresets() {\n    return new Promise((resolve, reject) => {\n      this.db.all(`\nSELECT *\nFROM presets \n`,\n        [],\n        (err, rows) => {\n          if (err === null) {\n            const answer = [];\n            if (rows !== undefined) {\n              for (const row of rows) {\n                answer.push(this.createPreset({\n                  id: row.id,\n                  name: row.name,\n                  stationApps: JSON.parse(row.stationApps),\n                }));\n              }\n            }\n            resolve(answer);\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n\n  /**\n   * Loads a Preset object with a certain ID\n   *\n   * @param {String} id\n   * @return {Promise}\n   *  The promise resolves to a Preset or null if it doesn't exist\n   */\n  loadPreset(id) {\n    return new Promise((resolve, reject) => {\n      this.db.get(`\nSELECT *\nFROM presets \nWHERE id = $id\n`,\n        {\n          $id: id,\n        },\n        (err, row) => {\n          if (err === null) {\n            if (row !== undefined) {\n              const answer = this.createPreset();\n              answer.id = row.id;\n              answer.name = row.name;\n              answer.stationApps = JSON.parse(row.stationApps);\n              resolve(answer);\n            } else {\n              resolve(null);\n            }\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Inserts a Preset in the database\n   *\n   * @param {Preset} preset\n   * @return {Promise}\n   */\n  insertPreset(preset) {\n    return new Promise((resolve, reject) => {\n      this.db.run(`\nINSERT INTO presets (name, stationApps)\nVALUES ($name, $stationApps)\n`,\n        {\n          $name: preset.name,\n          $stationApps: JSON.stringify(preset.stationApps),\n        },\n        function callback(err) {\n          if (err === null) {\n            resolve(this.lastID);\n          } else {\n            reject(PresetStore.checkDuplicateNameError(err));\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Updates a Preset in the database\n   *\n   * @param {Preset} preset\n   * @return {Promise}\n   */\n  updatePreset(preset) {\n    return new Promise((resolve, reject) => {\n      this.db.run(`\nUPDATE presets\nSET name = $name, stationApps = $stationApps\nWHERE id = $id\n`,\n        {\n          $id: preset.id,\n          $name: preset.name,\n          $stationApps: JSON.stringify(preset.stationApps),\n        },\n        (err) => {\n          if (err === null) {\n            resolve();\n          } else {\n            reject(PresetStore.checkDuplicateNameError(err));\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Removes a Preset from the database\n   *\n   * @param {Preset} preset\n   * @return {Promise}\n   */\n  removePreset(preset) {\n    return new Promise((resolve, reject) => {\n      this.db.run(`\nDELETE FROM presets\nWHERE id = $id\n`,\n        {\n          $id: preset.id,\n        },\n        (err) => {\n          if (err === null) {\n            resolve();\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Returns a list of all presets as {id, name} objects.\n   *\n   * @return {Promise}\n   */\n  listAllPresets() {\n    return new Promise((resolve, reject) => {\n      this.db.all(`\nSELECT id, name\nFROM presets\nORDER BY name\n      `, [], (err, rows) => {\n        if (err !== null) {\n          reject();\n        } else {\n          const answer = [];\n          if (rows !== undefined) {\n            for (const row of rows) {\n              answer.push({\n                id: row.id,\n                name: row.name,\n              });\n            }\n          }\n          resolve(answer);\n        }\n      });\n    });\n  }\n\n  /**\n   * Checks an error to see if it was caused by a duplicate name and translates it\n   * @param err\n   */\n  static checkDuplicateNameError(err) {\n    if (err.errno === 19) {\n      return new DuplicateIdentifierError('A preset with the selected name already exists');\n    }\n    return err;\n  }\n}\n"],"sourceRoot":"/source/"}