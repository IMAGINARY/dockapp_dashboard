{"version":3,"sources":["lib/presets/preset-store.js"],"names":["sqlite3","require","Promise","PresetStore","db","filename","resolve","reject","Database","OPEN_READWRITE","OPEN_CREATE","err","then","tableExists","exists","createTables","close","get","$table","row","undefined","run","id","$id","answer","name","stationData","JSON","parse","preset","$name","$stationData","stringify","callback","lastID","checkDuplicateNameError","all","rows","push","errno"],"mappings":"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","file":"lib/presets/preset-store.js","sourcesContent":["import Preset from './preset';\nimport DuplicateIdentifierError from './duplicate-identifier-error';\n\nconst sqlite3 = require('sqlite3');\nconst Promise = require('bluebird');\n\n/**\n * Manages Preset persistant storage\n */\nexport default class PresetStore {\n\n  constructor() {\n    this.db = null;\n  }\n\n  /**\n   * Opens the store database and inits it if needed\n   *\n   * After opening the database checks if the tables exist and creates them if they don't.\n   *\n   * @param filename\n   *   Filename of the database file or ':memory:' for an anonymous in-memory database\n   *   or an empty string for an anonymous disk-based database.\n   *\n   * @return {Promise}\n   */\n  open(filename) {\n    return new Promise((resolve, reject) => {\n      this.db = new sqlite3.Database(\n        filename,\n        sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, // eslint-disable-line no-bitwise\n        (err) => {\n          if (err === null) {\n            resolve();\n          } else {\n            reject(err);\n          }\n        });\n    })\n    .then(() => this.tableExists())\n    .then((exists) => {\n      if (!exists) {\n        return this.createTables();\n      }\n      return Promise.resolve();\n    });\n  }\n\n  /**\n   * Closes the database\n   *\n   * @return {Promise}\n   */\n  close() {\n    return new Promise((resolve, reject) => {\n      this.db.close((err) => {\n        if (err === null) {\n          this.db = null;\n          resolve();\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n\n  /**\n   * Checks if the storage table exists in the database\n   *\n   * @return {Ì¦Promise}\n   *  The promise resolves to a bool with the answer\n   */\n  tableExists() {\n    return new Promise((resolve, reject) => {\n      this.db.get(\"SELECT name FROM sqlite_master WHERE type='table' AND name=$table;\",\n        { $table: 'presets' },\n        (err, row) => {\n          if (err === null) {\n            resolve(row !== undefined);\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Creates the storage tables in the database\n   *\n   * @return {Promise}\n   */\n  createTables() {\n    return new Promise((resolve, reject) => {\n      this.db.run(`\nCREATE TABLE IF NOT EXISTS presets \n(\n  id integer PRIMARY KEY NOT NULL,\n  name text UNIQUE, \n  stationData text\n)\n`,\n        [],\n        (err) => {\n          if (err === null) {\n            resolve();\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Creates a Preset object associated to this store\n   *\n   * @return {Preset}\n   */\n  createPreset() {\n    return new Preset(this);\n  }\n\n  /**\n   * Loads a Preset object with a certain ID\n   *\n   * @param {String} id\n   * @return {Promise}\n   *  The promise resolves to a Preset or null if it doesn't exist\n   */\n  loadPreset(id) {\n    return new Promise((resolve, reject) => {\n      this.db.get(`\nSELECT *\nFROM presets \nWHERE id = $id\n`,\n        {\n          $id: id,\n        },\n        (err, row) => {\n          if (err === null) {\n            if (row !== undefined) {\n              const answer = new Preset(this);\n              answer.id = row.id;\n              answer.name = row.name;\n              answer.stationData = JSON.parse(row.stationData);\n              resolve(answer);\n            } else {\n              resolve(null);\n            }\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Inserts a Preset in the database\n   *\n   * @param {Preset} preset\n   * @return {Promise}\n   */\n  insertPreset(preset) {\n    return new Promise((resolve, reject) => {\n      this.db.run(`\nINSERT INTO presets (name, stationData)\nVALUES ($name, $stationData)\n`,\n        {\n          $name: preset.name,\n          $stationData: JSON.stringify(preset.stationData),\n        },\n        function callback(err) {\n          if (err === null) {\n            resolve(this.lastID);\n          } else {\n            reject(PresetStore.checkDuplicateNameError(err));\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Updates a Preset in the database\n   *\n   * @param {Preset} preset\n   * @return {Promise}\n   */\n  updatePreset(preset) {\n    return new Promise((resolve, reject) => {\n      this.db.run(`\nUPDATE presets\nSET name = $name, stationData = $stationData\nWHERE id = $id\n`,\n        {\n          $id: preset.id,\n          $name: preset.name,\n          $stationData: JSON.stringify(preset.stationData),\n        },\n        (err) => {\n          if (err === null) {\n            resolve();\n          } else {\n            reject(PresetStore.checkDuplicateNameError(err));\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Removes a Preset from the database\n   *\n   * @param {Preset} preset\n   * @return {Promise}\n   */\n  removePreset(preset) {\n    return new Promise((resolve, reject) => {\n      this.db.run(`\nDELETE FROM presets\nWHERE id = $id\n`,\n        {\n          $id: preset.id,\n        },\n        (err) => {\n          if (err === null) {\n            resolve();\n          } else {\n            reject(err);\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * Returns a list of all presets as {id, name} objects.\n   *\n   * @return {Promise}\n   */\n  listAllPresets() {\n    return new Promise((resolve, reject) => {\n      this.db.all(`\nSELECT id, name\nFROM presets\nORDER BY name\n      `, [], (err, rows) => {\n        if (err !== null) {\n          reject();\n        } else {\n          const answer = [];\n          if (rows !== undefined) {\n            for (const row of rows) {\n              answer.push({\n                id: row.id,\n                name: row.name,\n              });\n            }\n          }\n          resolve(answer);\n        }\n      });\n    });\n  }\n\n  /**\n   * Checks an error to see if it was caused by a duplicate name and translates it\n   * @param err\n   */\n  static checkDuplicateNameError(err) {\n    if (err.errno === 19) {\n      return new DuplicateIdentifierError('A preset with the selected name already exists');\n    }\n    return err;\n  }\n}\n"],"sourceRoot":"/source/"}