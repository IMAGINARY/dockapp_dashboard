// Compiled by Babel
// ** DO NOT EDIT THIS FILE DIRECTLY **
//
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Promise = require('bluebird');
var exec = require('child_process').exec;

/**
 * Interface with hilbert-cli
 *
 * This class doesn't check the state of the stations before dispatching
 * the commands.
 */

var HilbertCLIConnector = function () {
  function HilbertCLIConnector(nconf, logger) {
    _classCallCheck(this, HilbertCLIConnector);

    this.nconf = nconf;
    this.logger = logger;
  }

  /**
   * Reads the Hilbert Cfg
   * @param {stream.Writable} output
   * @returns {Promise<Object>} Hilbert cfg object
   */


  _createClass(HilbertCLIConnector, [{
    key: 'getHilbertCfg',
    value: function getHilbertCfg(output) {
      var _this = this;

      this.logger.verbose('hilbert-cli: Getting station config');
      return new Promise(function (resolve, reject) {
        _this.execute(_this.nconf.get('hilbert_cli') + ' ' + HilbertCLIConnector.COMMAND_DUMP_CFG, output).then(function (answer) {
          _this.logger.debug('hilbert-cli: Station config read:\n' + answer);
          var stationCfg = JSON.parse(answer);
          if (!(stationCfg instanceof Object)) {
            throw new Error('hilbert-cli returned an invalid station config: ' + answer);
          }
          if (stationCfg.length === 0) {
            throw new Error('hilbert-cli returned an empty station config.');
          }
          resolve(stationCfg);
        }).catch(function (err) {
          _this.logger.error('hilbert-cli: Error getting station config \'' + err.message + '\'');
          reject(err);
        });
      });
    }

    /**
     * Start a station
     * @param {string} stationID - ID of the station
     * @param {stream.Writable} output - Command output should be written here
     * @returns Promise
     */

  }, {
    key: 'startStation',
    value: function startStation(stationID, output) {
      var _this2 = this;

      this.logger.verbose('hilbert-cli: Starting station ' + stationID);
      return new Promise(function (resolve, reject) {
        _this2.execute(_this2.nconf.get('hilbert_cli') + ' ' + HilbertCLIConnector.COMMAND_START + ' ' + stationID, output).then(function () {
          resolve();
        }).catch(function (err) {
          _this2.logger.error('hilbert-cli: Error starting station ' + stationID + ', \'' + err.message + '\'');
          reject(err);
        });
      });
    }

    /**
     * Stop a station
     * @param {string} stationID - ID of the station
     * @param {stream.Writable} output - Command output should be written here
     * @returns Promise
     */

  }, {
    key: 'stopStation',
    value: function stopStation(stationID, output) {
      var _this3 = this;

      this.logger.verbose('hilbert-cli: Stopping station ' + stationID);
      return new Promise(function (resolve, reject) {
        _this3.execute(_this3.nconf.get('hilbert_cli') + ' ' + HilbertCLIConnector.COMMAND_STOP + ' ' + stationID, output).then(function () {
          resolve();
        }).catch(function (err) {
          _this3.logger.error('hilbert-cli: Error stopping station ' + stationID + ', \'' + err.message + '\'');
          reject(err);
        });
      });
    }

    /**
     * Change the foreground application running in a station
     * @param {string} stationID - ID of the station
     * @param {string} appID - ID of the app to set
     * @param {stream.Writable} output - Command output should be written here
     * @returns {Promise}
     */

  }, {
    key: 'changeApp',
    value: function changeApp(stationID, appID, output) {
      var _this4 = this;

      this.logger.verbose('hilbert-cli: Changing app of station ' + stationID + ' to ' + appID);
      return new Promise(function (resolve, reject) {
        _this4.execute(_this4.nconf.get('hilbert_cli') + ' ' + HilbertCLIConnector.COMMAND_CHANGE_APP + ' ' + stationID + ' ' + appID, output).then(function () {
          resolve();
        }).catch(function (err) {
          _this4.logger.error('hilbert-cli: Error changing station ' + stationID + ' to app ' + appID + ', \'' + err.message + '\'');
          reject(err);
        });
      });
    }

    /**
     * Executes a child process
     * @private
     *
     * @param {string} command - Command to execute
     * @param {stream.Writable} output - Command output should be written here
     * @param {object} options - Options to pass child_process.exec
     * @returns {Promise}
     * @resolve {String} - stdout output
     * @reject {Error}
     */

  }, {
    key: 'execute',
    value: function execute(command, output) {
      var _this5 = this;

      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      return new Promise(function (resolve, reject) {
        var stdoutBuf = '';
        var alloutBuf = '';
        _this5.logger.verbose('Executing \'' + command + '\'');

        var execOptions = Object.assign({}, options); // clone

        if (!('env' in execOptions)) {
          execOptions.env = Object.assign({}, process.env);
        } else {
          execOptions.env = Object.assign({}, process.env, execOptions.env);
        }
        if (!('HILBERT_CLI_PATH' in execOptions.env)) {
          execOptions.env.HILBERT_CLI_PATH = _this5.nconf.get('hilbert_cli');
        }
        if (!('HILBERT_SERVER_CONFIG_PATH' in execOptions.env)) {
          execOptions.env.HILBERT_SERVER_CONFIG_PATH = _this5.nconf.get('hilbert_cfg');
        }

        // This setting below is needed to avoid issues in mac
        // When running from the IDE my env had the invalid locale en_AR.UTF-8
        // (Argentine english???) and this caused a fallback to ascii for ruamel
        // reading the config file.
        execOptions.env.LC_CTYPE = 'UTF-8';

        var childProcess = exec(command, execOptions);
        childProcess.stdout.on('data', function (data) {
          stdoutBuf += data;
          alloutBuf += data;
          output.write(data);
        });
        childProcess.stderr.on('data', function (data) {
          alloutBuf += data;
          output.write(data);
        });
        childProcess.on('close', function (code, signal) {
          if (code === 0) {
            _this5.logger.verbose('Execution of ' + command + ' finished with code 0 (success).');
            resolve(stdoutBuf);
          } else {
            var term = 'rc=' + code;
            if (signal !== null) {
              term = term + ', ' + signal;
            }
            _this5.logger.error('Execution of ' + command + ' finished with ' + term + '.');
            _this5.logger.verbose('Output:');
            _this5.logger.verbose(alloutBuf);
            reject(new Error('Command \'' + command + '\' exited with ' + term + '. ' + alloutBuf));
          }
        });
      });
    }
  }]);

  return HilbertCLIConnector;
}();

exports.default = HilbertCLIConnector;


HilbertCLIConnector.COMMAND_DUMP_CFG = 'cfg_query -f json';
HilbertCLIConnector.COMMAND_START = 'poweron';
HilbertCLIConnector.COMMAND_STOP = 'poweroff';
HilbertCLIConnector.COMMAND_CHANGE_APP = 'app_change';
//# sourceMappingURL=hilbert-cli-connector.js.map
