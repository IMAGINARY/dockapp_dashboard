// Compiled by Babel
// ** DO NOT EDIT THIS FILE DIRECTLY **
//
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Promise = require('bluebird');
var exec = require('child_process').exec;

/**
 * Interface with DockApp via scripts
 *
 * This class doesn't check the state of the stations before dispatching
 * the commands.
 */

var DockAppConnector = function () {
  function DockAppConnector(nconf, logger) {
    _classCallCheck(this, DockAppConnector);

    this.nconf = nconf;
    this.logger = logger;
  }

  /**
   * Reads the station config
   * @param {TerminalOutputBuffer} output
   * @returns {Promise}
   * @resolve {Array} - List of stations
   * @reject {Error}
   */


  _createClass(DockAppConnector, [{
    key: 'getStationConfig',
    value: function getStationConfig(output) {
      var _this = this;

      this.logger.verbose('DockApp: Getting station config');
      return new Promise(function (resolve, reject) {
        _this.execute(DockAppConnector.SCRIPT_LIST_STATIONS, output).then(function (answer) {
          _this.logger.debug('DockApp: Station config read:\n' + answer);
          var stationCfg = JSON.parse(answer);
          if (!stationCfg instanceof Array) {
            throw new Error('Dockapp returned an invalid station config: ' + answer);
          }
          if (stationCfg.length === 0) {
            throw new Error('Dockapp returned an empty station config.');
          }
          resolve(stationCfg);
        }).catch(function (err) {
          _this.logger.error('DockApp: Error getting station config \'' + err.message + '\'');
          reject(err);
        });
      });
    }

    /**
     * Start a station
     * @param {string} stationID - ID of the station
     * @param {stream} output - Command output should be written here
     * @returns Promise
     */

  }, {
    key: 'startStation',
    value: function startStation(stationID, output) {
      var _this2 = this;

      this.logger.verbose('DockApp: Starting station ' + stationID);
      return new Promise(function (resolve, reject) {
        _this2.execute(DockAppConnector.SCRIPT_START_STATION + ' ' + stationID, output).then(function () {
          resolve();
        }).catch(function (err) {
          _this2.logger.error('DockApp: Error starting station ' + stationID + ', \'' + err.message + '\'');
          reject(err);
        });
      });
    }

    /**
     * Stop a station
     * @param {string} stationID - ID of the station
     * @param {stream} output - Command output should be written here
     * @returns Promise
     */

  }, {
    key: 'stopStation',
    value: function stopStation(stationID, output) {
      var _this3 = this;

      this.logger.verbose('DockApp: Stopping station ' + stationID);
      return new Promise(function (resolve, reject) {
        _this3.execute(DockAppConnector.SCRIPT_STOP_STATION + ' ' + stationID, output).then(function () {
          resolve();
        }).catch(function (err) {
          _this3.logger.error('DockApp: Error stopping station ' + stationID + ', \'' + err.message + '\'');
          reject(err);
        });
      });
    }

    /**
     * Change the foreground application running in a station
     * @param {string} stationID - ID of the station
     * @param {string} appID - ID of the app to set
     * @param {stream} output - Command output should be written here
     * @returns {Promise}
     */

  }, {
    key: 'changeApp',
    value: function changeApp(stationID, appID, output) {
      var _this4 = this;

      this.logger.verbose('DockApp: Changing app of station ' + stationID + ' to ' + appID);
      return new Promise(function (resolve, reject) {
        _this4.execute(DockAppConnector.SCRIPT_CHANGE_APP + ' ' + stationID + ' ' + appID, output).then(function () {
          resolve();
        }).catch(function (err) {
          _this4.logger.error('DockApp: Error changing station ' + stationID + ' to app ' + appID + ', \'' + err.message + '\'');
          reject(err);
        });
      });
    }

    /**
     * Executes a child process
     * @private
     *
     * @param {string} command - Command to execute
     * @param {stream} output - Command output should be written here
     * @param {object} options - Options to pass child_process.exec
     * @returns {Promise}
     * @resolve {String} - stdout output
     * @reject {Error}
     */

  }, {
    key: 'execute',
    value: function execute(command, output, options) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var stdoutBuf = '';
        var alloutBuf = '';
        _this5.logger.verbose('Executing \'' + command + '\'');

        var execOptions = Object.assign({}, options); // clone

        if (!execOptions.hasOwnProperty('env')) {
          execOptions.env = {};
        }
        if (!execOptions.env.hasOwnProperty('DOCKAPP_PATH')) {
          execOptions.env.DOCKAPP_PATH = _this5.nconf.get('dockapp_path');
        }

        var process = exec(command, execOptions);
        process.stdout.on('data', function (data) {
          stdoutBuf += data;
          alloutBuf += data;
          output.write(data);
        });
        process.stderr.on('data', function (data) {
          alloutBuf += data;
          output.write(data);
        });
        process.on('close', function (code, signal) {
          if (code === 0) {
            _this5.logger.verbose('Execution of ' + command + ' finished with code 0 (success).');
            resolve(stdoutBuf);
          } else {
            var term = 'rc=' + code;
            if (signal !== null) {
              term = term + ', ' + signal;
            }
            _this5.logger.error('Execution of ' + command + ' finished with ' + term + '.');
            _this5.logger.verbose('Output:');
            _this5.logger.verbose(alloutBuf);
            reject(new Error('Command \'' + command + '\' exited with ' + term + '. ' + alloutBuf));
          }
        });
      });
    }
  }]);

  return DockAppConnector;
}();

exports.default = DockAppConnector;


DockAppConnector.SCRIPT_LIST_STATIONS = './scripts/list_stations.sh';
DockAppConnector.SCRIPT_START_STATION = './scripts/start_station.sh';
DockAppConnector.SCRIPT_STOP_STATION = './scripts/stop_station.sh';
DockAppConnector.SCRIPT_CHANGE_APP = './scripts/appchange_station.sh';
//# sourceMappingURL=dockapp-connector.js.map
