{"version":3,"sources":["lib/station-manager.js"],"names":["Promise","require","EventEmitter","Ajv","HilbertCfgSchema","StationManager","nconf","logger","hilbertCLI","mkLivestatus","events","notifications","lastNotificationID","globalHilbertCLIOutputBuffer","lastMKLivestatusDump","lastMKLivestatusDumpTime","clearStations","clearStationProfiles","clearApplications","loadHilbertCfg","then","pollLoopBody","pollDelay","get","consecutiveErrors","errorDigestSize","pollMKLivestatus","setTimeout","catch","error","signalUpdate","getHilbertCfg","validateHilbertCfg","hilbertCfg","Object","entries","Applications","appID","appCfg","addApplication","Profiles","profileID","profileCfg","addStationProfile","Stations","stationID","stationCfg","hidden","addStation","stationProfile","verbose","id","stationProfiles","set","application","applications","aStation","stationList","push","stationIndex","on","station","type","message","details","notify","extraText","undefined","info","warn","i","indexOf","splice","delete","Map","values","stationIDs","eligibleStations","getStationByID","setQueuedToStartState","map","eligibleStation","setStartingState","invalidateAppState","startStation","outputBuffer","setErrorState","errorLock","concurrency","setQueuedToStopState","setStoppingState","stopStation","setQueuedToChangeAppState","setChangingAppState","changeApp","newNotification","time","Date","toISOString","station_id","station_name","name","maxNotifications","length","slice","emit","getState","allStationsStatus","lastState","changes","stationStatus","updateFromMKLivestatus","ajv","validate","Error","errorsText"],"mappings":"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","file":"lib/station-manager.js","sourcesContent":["import Station from './station';\nimport StationProfile from './station-profile';\nimport Application from './application';\nimport TerminalOutputBuffer from './terminal-output-buffer';\n\nconst Promise = require('bluebird');\nconst EventEmitter = require('events').EventEmitter;\nconst Ajv = require('ajv');\n\nconst HilbertCfgSchema = require('../../data/schema/hilbert-cfg-partial.json');\n\n/**\n * Service Layer for hilbert\n * Dispatches requests asynchronously and keeps cached state\n */\nexport default class StationManager {\n\n  /**\n   * Create a Station Manager\n   *\n   * @param {Object} nconf - Instance of nconf configuration\n   * @param {Object} logger - Instance of winston logger\n   * @param {HilbertCLIConnector} hilbertCLI - hilbert-cli connector\n   * @param {MKLivestatusConnector} mkLivestatus - MKLivestatus connector\n   */\n  constructor(nconf, logger, hilbertCLI, mkLivestatus) {\n    this.nconf = nconf;\n    this.logger = logger;\n\n    this.hilbertCLI = hilbertCLI;\n    this.mkLivestatus = mkLivestatus;\n\n    this.events = new EventEmitter();\n    this.notifications = [];\n    this.lastNotificationID = 1;\n\n    this.globalHilbertCLIOutputBuffer = new TerminalOutputBuffer();\n    this.lastMKLivestatusDump = [];\n    this.lastMKLivestatusDumpTime = '';\n\n    this.clearStations();\n    this.clearStationProfiles();\n    this.clearApplications();\n  }\n\n  /**\n   * Reads the station configuration and begins polling station status\n   *\n   * @return {Promise}\n   */\n  init() {\n    return this.loadHilbertCfg().then(() => {\n      const pollLoopBody = () => {\n        const pollDelay = this.nconf.get('mkls_poll_delay');\n        let consecutiveErrors = 0;\n        const errorDigestSize = 50;\n        this.pollMKLivestatus().then(() => {\n          consecutiveErrors = 0;\n          setTimeout(pollLoopBody, pollDelay);\n        }).catch(() => {\n          if (consecutiveErrors % errorDigestSize) {\n            if (consecutiveErrors !== 0) {\n              this.logger.error(\n                `Station manager: Repeated MKLivestatus polling errors (${errorDigestSize} times)`);\n            }\n          }\n          consecutiveErrors += 1;\n          setTimeout(pollLoopBody, pollDelay);\n        });\n      };\n      pollLoopBody();\n    });\n  }\n\n  /**\n   * Loads the station configuration.\n   *\n   * If the configuration was already loaded this method clears it\n   * and reloads everything\n   *\n   * @returns {Promise}\n   */\n  loadHilbertCfg() {\n    this.clearStations();\n    this.clearStationProfiles();\n    this.clearApplications();\n    this.signalUpdate();\n\n    return this.hilbertCLI.getHilbertCfg(this.globalHilbertCLIOutputBuffer)\n      .then(hilbertCfg => StationManager.validateHilbertCfg(hilbertCfg))\n      .then((hilbertCfg) => {\n        for (const [appID, appCfg] of Object.entries(hilbertCfg.Applications)) {\n          this.addApplication(new Application(appID, appCfg));\n        }\n\n        for (const [profileID, profileCfg] of Object.entries(hilbertCfg.Profiles)) {\n          this.addStationProfile(new StationProfile(profileID, profileCfg));\n        }\n\n        for (const [stationID, stationCfg] of Object.entries(hilbertCfg.Stations)) {\n          if (!stationCfg.hidden) {\n            this.addStation(new Station(stationID, stationCfg, this.nconf));\n          }\n        }\n        this.signalUpdate();\n      });\n  }\n\n  /**\n   * Adds a station profile\n   *\n   * @param {StationProfile} stationProfile\n   */\n  addStationProfile(stationProfile) {\n    this.logger.verbose(`Station manager: Adding station profile ${stationProfile.id}`);\n    this.stationProfiles.set(stationProfile.id, stationProfile);\n  }\n\n  /**\n   * Adds an application\n   *\n   * @param {Application} application\n   */\n  addApplication(application) {\n    this.logger.verbose(`Station manager: Adding application profile ${application.id}`);\n    this.applications.set(application.id, application);\n  }\n\n  /**\n   * Adds a station to the manager\n   * @param {Station} aStation\n   */\n  addStation(aStation) {\n    this.logger.verbose(`Station manager: Adding station ${aStation.id}`);\n    this.stationList.push(aStation);\n    this.stationIndex.set(aStation.id, aStation);\n    aStation.events.on('stateChange', (station, type, message, details) => {\n      this.notify(type, station, message, details);\n\n      let extraText = '';\n      if (details !== undefined) {\n        extraText = ` (${details})`;\n      }\n      if (type === 'info') {\n        this.logger.info(`Station manager: ${station.id}: ${message}${extraText}`);\n      } else if (type === 'warning') {\n        this.logger.warn(`Station manager: ${station.id}: ${message}${extraText}`);\n      } else if (type === 'error') {\n        this.logger.error(`Station manager: ${station.id}: ${message}${extraText}`);\n      } else {\n        this.logger.verbose(`Station manager: ${station.id}: ${message}${extraText}`);\n      }\n    });\n  }\n\n  /**\n   * Removes a station from the manager\n   * @param {Station} aStation\n   */\n  removeStation(aStation) {\n    this.logger.verbose(`Station manager: Removing station ${aStation.id}`);\n    const i = this.stationList.indexOf(aStation);\n    if (i !== -1) {\n      this.stationList.splice(i, 1);\n    }\n\n    this.stationIndex.delete(aStation.id);\n  }\n\n  /**\n   * Removes all the stations\n   */\n  clearStations() {\n    this.logger.verbose('Station manager: Clearing all stations');\n    this.stationIndex = new Map();\n    this.stationList = [];\n  }\n\n  /**\n   * Removes all the station profiles\n   */\n  clearStationProfiles() {\n    this.logger.verbose('Station manager: Clearing all station profiles');\n    this.stationProfiles = new Map();\n  }\n\n  /**\n   * Removes all the applications\n   */\n  clearApplications() {\n    this.logger.verbose('Station manager: Clearing all applications');\n    this.applications = new Map();\n  }\n\n  /**\n   * Returns the station profiles\n   *\n   * @return {Iterator.<StationProfile>}\n   */\n  getStationProfiles() {\n    return this.stationProfiles.values();\n  }\n\n  /**\n   * Returns the applications\n   *\n   * @return {Iterator.<Application>}\n   */\n  getApplications() {\n    return this.applications.values();\n  }\n\n  /**\n   * Get the ordered list of stations\n   * @returns {Array}\n   */\n  getStations() {\n    return this.stationList;\n  }\n\n  /**\n   * Return a station identified by ID\n   *\n   * @param {string} id - Station ID\n   * @returns {Station}\n   */\n  getStationByID(id) {\n    return this.stationIndex.get(id);\n  }\n\n  /**\n   * Start indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations to start\n   * @return {Promise}\n   */\n  startStations(stationIDs) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToStartState()) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(`Station manager: Starting station ${eligibleStation}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setStartingState();\n        this.signalUpdate();\n        this.mkLivestatus.invalidateAppState(station.id);\n        return this.hilbertCLI.startStation(station.id, station.outputBuffer).then(() => {\n          this.logger.verbose(`Station manager: Waiting for station ${eligibleStation} to start`);\n        })\n        .catch(() => {\n          this.logger.verbose(`Station manager: Error starting station ${eligibleStation}`);\n          this.notify('error', station, 'Error starting station');\n          station.setErrorState('Failure starting the station. Please wait...');\n          station.errorLock();\n        })\n        .then(() => {\n          this.signalUpdate();\n        });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Stop indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations to stop\n   * @return {Promise}\n   */\n  stopStations(stationIDs) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToStopState()) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(`Station manager: Stopping station ${eligibleStation}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setStoppingState();\n        this.signalUpdate();\n        return this.hilbertCLI.stopStation(station.id, station.outputBuffer).then(() => {\n          this.logger.verbose(`Station manager: Waiting for station ${eligibleStation} to stop`);\n        })\n          .catch(() => {\n            this.logger.verbose(`Station manager: Error stopping station ${eligibleStation}`);\n            this.notify('error', station, 'Error stopping station');\n            station.setErrorState('Failure stopping the station. Please wait...');\n            station.errorLock();\n          })\n          .then(() => {\n            this.signalUpdate();\n          });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Change the application running in indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations in which to change the appID\n   * @param {string} appID - Name of the appID to run\n   * @return {Promise}\n   */\n  changeApp(stationIDs, appID) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToChangeAppState(appID)) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(\n          `Station manager: Changing app of station ${eligibleStation} to ${appID}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setChangingAppState(appID);\n        this.signalUpdate();\n        return this.hilbertCLI.changeApp(eligibleStation, appID, station.outputBuffer).then(() => {\n          this.logger.verbose(\n            `Station manager: Waiting for app of station ${eligibleStation} to change to ${appID}`);\n        })\n        .catch(() => {\n          this.logger.verbose(\n            `Station manager: Error changing app of station ${eligibleStation} to ${appID}`);\n          this.notify('error', station, `Failed to launch app ${appID}`);\n          station.setErrorState(`Failed to open ${appID}. Please wait...`);\n          station.errorLock();\n        })\n        .then(() => {\n          this.signalUpdate();\n        });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Return the notification log\n   *\n   * Each notification is an object with the following structure:\n   * - id {string} : Unique id of the entry\n   * - time {string} : Timestamp in ISO format\n   * - type {string} : info | warning | error\n   * - message {string} : Event description\n   *\n   * @returns {Array}\n   */\n  getNotifications() {\n    return this.notifications;\n  }\n\n  /**\n   * Generates a notification\n   *\n   * @param {string} type - Notification type: info | warning | error\n   * @param {Station|null} station - station associated with the event logged\n   * @param {string} message - Text of the notification\n   * @param {string} details - Extra details\n   */\n  notify(type, station, message, details = '') {\n    const newNotification = {\n      id: this.lastNotificationID,\n      time: new Date().toISOString(),\n      type,\n      message,\n      details,\n    };\n\n    if (station !== null) {\n      newNotification.station_id = station.id;\n      newNotification.station_name = station.name;\n    }\n\n    this.lastNotificationID += 1;\n    this.notifications.push(newNotification);\n    const maxNotifications = this.nconf.get('max_notifications');\n    if (this.notifications.length > maxNotifications) {\n      this.notifications = this.notifications.slice(this.notifications.length - maxNotifications);\n    }\n\n    this.events.emit('notification', newNotification);\n  }\n\n  /**\n   * Polls MKLivestatus and updates the state of stations\n   * @returns {Promise}\n   */\n  pollMKLivestatus() {\n    return this.mkLivestatus.getState().then((allStationsStatus) => {\n      const lastState = [];\n      let changes = false;\n      for (const stationStatus of allStationsStatus) {\n        lastState.push(stationStatus);\n        const station = this.getStationByID(stationStatus.id);\n        if (station) {\n          if (station.updateFromMKLivestatus(stationStatus)) {\n            changes = true;\n          }\n        }\n      }\n      this.lastMKLivestatusDump = lastState;\n      this.lastMKLivestatusDumpTime = new Date().toISOString();\n\n      if (changes) {\n        this.signalUpdate();\n      }\n    });\n  }\n  /**\n   * Signal listeners that station data was modified\n   * @private\n   */\n  signalUpdate() {\n    this.events.emit('stationUpdate');\n  }\n\n\n  /**\n   * Validates a hilbert configuration according to the schema\n   *\n   * Only the parts of the configuration used by this program are validated\n   *\n   * @param hilbertCfg\n   * @return {*}\n   */\n  static validateHilbertCfg(hilbertCfg) {\n    const ajv = new Ajv();\n    if (!ajv.validate(HilbertCfgSchema, hilbertCfg)) {\n      throw new Error(`Error in Hilbert CFG: ${ajv.errorsText()}`);\n    }\n    return hilbertCfg;\n  }\n}\n"],"sourceRoot":"/source/"}