{"version":3,"sources":["lib/station-manager.js"],"names":["Promise","require","EventEmitter","Ajv","HilbertCfgSchema","StationManager","nconf","logger","hilbertCLI","mkLivestatus","events","notifications","lastNotificationID","globalHilbertCLIOutputBuffer","lastMKLivestatusDump","clearStations","clearStationProfiles","clearApplications","loadHilbertCfg","then","pollLoopBody","pollDelay","get","consecutiveErrors","errorDigestSize","pollMKLivestatus","setTimeout","catch","error","signalUpdate","getHilbertCfg","validateHilbertCfg","hilbertCfg","Object","entries","Applications","appID","appCfg","addApplication","Profiles","profileID","profileCfg","addStationProfile","Stations","stationID","stationCfg","hidden","addStation","stationProfile","verbose","id","stationProfiles","set","application","applications","aStation","stationList","push","stationIndex","on","station","type","message","notify","info","warn","i","indexOf","splice","delete","Map","values","stationIDs","eligibleStations","getStationByID","setQueuedToStartState","map","eligibleStation","setStartingState","startStation","outputBuffer","setErrorState","errorLock","concurrency","setQueuedToStopState","setStoppingState","stopStation","setQueuedToChangeAppState","setChangingAppState","changeApp","newNotification","time","Date","toISOString","station_id","station_name","name","maxNotifications","length","slice","emit","getState","allStationsStatus","lastState","changes","stationStatus","updateFromMKLivestatus","ajv","validate","Error","errorsText"],"mappings":"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","file":"lib/station-manager.js","sourcesContent":["import Station from './station';\nimport StationProfile from './station-profile';\nimport Application from './application';\nimport TerminalOutputBuffer from './terminal-output-buffer';\n\nconst Promise = require('bluebird');\nconst EventEmitter = require('events').EventEmitter;\nconst Ajv = require('ajv');\n\nconst HilbertCfgSchema = require('../../data/schema/hilbert-cfg-partial.json');\n\n/**\n * Service Layer for hilbert\n * Dispatches requests asynchronously and keeps cached state\n */\nexport default class StationManager {\n\n  /**\n   * Create a Station Manager\n   *\n   * @param {Object} nconf - Instance of nconf configuration\n   * @param {Object} logger - Instance of winston logger\n   * @param {HilbertCLIConnector} hilbertCLI - hilbert-cli connector\n   * @param {MKLivestatusConnector} mkLivestatus - MKLivestatus connector\n   */\n  constructor(nconf, logger, hilbertCLI, mkLivestatus) {\n    this.nconf = nconf;\n    this.logger = logger;\n\n    this.hilbertCLI = hilbertCLI;\n    this.mkLivestatus = mkLivestatus;\n\n    this.events = new EventEmitter();\n    this.notifications = [];\n    this.lastNotificationID = 1;\n\n    this.globalHilbertCLIOutputBuffer = new TerminalOutputBuffer();\n    this.lastMKLivestatusDump = [];\n\n    this.clearStations();\n    this.clearStationProfiles();\n    this.clearApplications();\n  }\n\n  /**\n   * Reads the station configuration and begins polling station status\n   *\n   * @return {Promise}\n   */\n  init() {\n    return this.loadHilbertCfg().then(() => {\n      const pollLoopBody = () => {\n        const pollDelay = this.nconf.get('mkls_poll_delay');\n        let consecutiveErrors = 0;\n        const errorDigestSize = 50;\n        this.pollMKLivestatus().then(() => {\n          consecutiveErrors = 0;\n          setTimeout(pollLoopBody, pollDelay);\n        }).catch(() => {\n          if (consecutiveErrors % errorDigestSize) {\n            if (consecutiveErrors !== 0) {\n              this.logger.error(\n                `Station manager: Repeated MKLivestatus polling errors (${errorDigestSize} times)`);\n            }\n          }\n          consecutiveErrors += 1;\n          setTimeout(pollLoopBody, pollDelay);\n        });\n      };\n      pollLoopBody();\n    });\n  }\n\n  /**\n   * Loads the station configuration.\n   *\n   * If the configuration was already loaded this method clears it\n   * and reloads everything\n   *\n   * @returns {Promise}\n   */\n  loadHilbertCfg() {\n    this.clearStations();\n    this.clearStationProfiles();\n    this.clearApplications();\n    this.signalUpdate();\n\n    return this.hilbertCLI.getHilbertCfg(this.globalHilbertCLIOutputBuffer)\n      .then(hilbertCfg => StationManager.validateHilbertCfg(hilbertCfg))\n      .then((hilbertCfg) => {\n        for (const [appID, appCfg] of Object.entries(hilbertCfg.Applications)) {\n          this.addApplication(new Application(appID, appCfg));\n        }\n\n        for (const [profileID, profileCfg] of Object.entries(hilbertCfg.Profiles)) {\n          this.addStationProfile(new StationProfile(profileID, profileCfg));\n        }\n\n        for (const [stationID, stationCfg] of Object.entries(hilbertCfg.Stations)) {\n          if (!stationCfg.hidden) {\n            this.addStation(new Station(stationID, stationCfg, this.nconf));\n          }\n        }\n        this.signalUpdate();\n      });\n  }\n\n  /**\n   * Adds a station profile\n   *\n   * @param {StationProfile} stationProfile\n   */\n  addStationProfile(stationProfile) {\n    this.logger.verbose(`Station manager: Adding station profile ${stationProfile.id}`);\n    this.stationProfiles.set(stationProfile.id, stationProfile);\n  }\n\n  /**\n   * Adds an application\n   *\n   * @param {Application} application\n   */\n  addApplication(application) {\n    this.logger.verbose(`Station manager: Adding application profile ${application.id}`);\n    this.applications.set(application.id, application);\n  }\n\n  /**\n   * Adds a station to the manager\n   * @param {Station} aStation\n   */\n  addStation(aStation) {\n    this.logger.verbose(`Station manager: Adding station ${aStation.id}`);\n    this.stationList.push(aStation);\n    this.stationIndex.set(aStation.id, aStation);\n    aStation.events.on('stateChange', (station, type, message) => {\n      this.notify(type, station, message);\n      if (type === 'info') {\n        this.logger.info(`Station manager: ${station.id}: ${message}`);\n      } else if (type === 'warning') {\n        this.logger.warn(`Station manager: ${station.id}: ${message}`);\n      } else if (type === 'error') {\n        this.logger.error(`Station manager: ${station.id}: ${message}`);\n      } else {\n        this.logger.verbose(`Station manager: ${station.id}: ${message}`);\n      }\n    });\n  }\n\n  /**\n   * Removes a station from the manager\n   * @param {Station} aStation\n   */\n  removeStation(aStation) {\n    this.logger.verbose(`Station manager: Removing station ${aStation.id}`);\n    const i = this.stationList.indexOf(aStation);\n    if (i !== -1) {\n      this.stationList.splice(i, 1);\n    }\n\n    this.stationIndex.delete(aStation.id);\n  }\n\n  /**\n   * Removes all the stations\n   */\n  clearStations() {\n    this.logger.verbose('Station manager: Clearing all stations');\n    this.stationIndex = new Map();\n    this.stationList = [];\n  }\n\n  /**\n   * Removes all the station profiles\n   */\n  clearStationProfiles() {\n    this.logger.verbose('Station manager: Clearing all station profiles');\n    this.stationProfiles = new Map();\n  }\n\n  /**\n   * Removes all the applications\n   */\n  clearApplications() {\n    this.logger.verbose('Station manager: Clearing all applications');\n    this.applications = new Map();\n  }\n\n  /**\n   * Returns the station profiles\n   *\n   * @return {Iterator.<StationProfile>}\n   */\n  getStationProfiles() {\n    return this.stationProfiles.values();\n  }\n\n  /**\n   * Returns the applications\n   *\n   * @return {Iterator.<Application>}\n   */\n  getApplications() {\n    return this.applications.values();\n  }\n\n  /**\n   * Get the ordered list of stations\n   * @returns {Array}\n   */\n  getStations() {\n    return this.stationList;\n  }\n\n  /**\n   * Return a station identified by ID\n   *\n   * @param {string} id - Station ID\n   * @returns {Station}\n   */\n  getStationByID(id) {\n    return this.stationIndex.get(id);\n  }\n\n  /**\n   * Start indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations to start\n   * @return {Promise}\n   */\n  startStations(stationIDs) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToStartState()) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(`Station manager: Starting station ${eligibleStation}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setStartingState();\n        this.signalUpdate();\n        return this.hilbertCLI.startStation(station.id, station.outputBuffer).then(() => {\n          this.logger.verbose(`Station manager: Waiting for station ${eligibleStation} to start`);\n        })\n        .catch(() => {\n          this.logger.verbose(`Station manager: Error starting station ${eligibleStation}`);\n          this.notify('error', station, 'Error starting station');\n          station.setErrorState('Failure starting the station. Please wait...');\n          station.errorLock();\n        })\n        .then(() => {\n          this.signalUpdate();\n        });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Stop indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations to stop\n   * @return {Promise}\n   */\n  stopStations(stationIDs) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToStopState()) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(`Station manager: Stopping station ${eligibleStation}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setStoppingState();\n        this.signalUpdate();\n        return this.hilbertCLI.stopStation(station.id, station.outputBuffer).then(() => {\n          this.logger.verbose(`Station manager: Waiting for station ${eligibleStation} to stop`);\n        })\n          .catch(() => {\n            this.logger.verbose(`Station manager: Error stopping station ${eligibleStation}`);\n            this.notify('error', station, 'Error stopping station');\n            station.setErrorState('Failure stopping the station. Please wait...');\n            station.errorLock();\n          })\n          .then(() => {\n            this.signalUpdate();\n          });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Change the application running in indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations in which to change the appID\n   * @param {string} appID - Name of the appID to run\n   * @return {Promise}\n   */\n  changeApp(stationIDs, appID) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToChangeAppState(appID)) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(\n          `Station manager: Changing app of station ${eligibleStation} to ${appID}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setChangingAppState(appID);\n        this.signalUpdate();\n        return this.hilbertCLI.changeApp(eligibleStation, appID, station.outputBuffer).then(() => {\n          this.logger.verbose(\n            `Station manager: Waiting for app of station ${eligibleStation} to change to ${appID}`);\n        })\n        .catch(() => {\n          this.logger.verbose(\n            `Station manager: Error changing app of station ${eligibleStation} to ${appID}`);\n          this.notify('error', station, `Failed to launch app ${appID}`);\n          station.setErrorState(`Failed to open ${appID}. Please wait...`);\n          station.errorLock();\n        })\n        .then(() => {\n          this.signalUpdate();\n        });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Return the notification log\n   *\n   * Each notification is an object with the following structure:\n   * - id {string} : Unique id of the entry\n   * - time {string} : Timestamp in ISO format\n   * - type {string} : info | warning | error\n   * - message {string} : Event description\n   *\n   * @returns {Array}\n   */\n  getNotifications() {\n    return this.notifications;\n  }\n\n  /**\n   * Generates a notification\n   *\n   * @param {string} type - Notification type: info | warning | error\n   * @param {Station|null} station - station associated with the event logged\n   * @param {string} message - Text of the notification\n   */\n  notify(type, station, message) {\n    const newNotification = {\n      id: this.lastNotificationID,\n      time: new Date().toISOString(),\n      type,\n      message,\n    };\n\n    if (station !== null) {\n      newNotification.station_id = station.id;\n      newNotification.station_name = station.name;\n    }\n\n    this.lastNotificationID += 1;\n    this.notifications.push(newNotification);\n    const maxNotifications = this.nconf.get('max_notifications');\n    if (this.notifications.length > maxNotifications) {\n      this.notifications = this.notifications.slice(this.notifications.length - maxNotifications);\n    }\n\n    this.events.emit('notification', newNotification);\n  }\n\n  /**\n   * Polls MKLivestatus and updates the state of stations\n   * @returns {Promise}\n   */\n  pollMKLivestatus() {\n    return this.mkLivestatus.getState().then((allStationsStatus) => {\n      const lastState = [];\n      let changes = false;\n      for (const stationStatus of allStationsStatus) {\n        lastState.push(stationStatus);\n        const station = this.getStationByID(stationStatus.id);\n        if (station) {\n          if (station.updateFromMKLivestatus(stationStatus)) {\n            changes = true;\n          }\n        }\n      }\n      this.lastMKLivestatusDump = lastState;\n\n      if (changes) {\n        this.signalUpdate();\n      }\n    });\n  }\n  /**\n   * Signal listeners that station data was modified\n   * @private\n   */\n  signalUpdate() {\n    this.events.emit('stationUpdate');\n  }\n\n\n  /**\n   * Validates a hilbert configuration according to the schema\n   *\n   * Only the parts of the configuration used by this program are validated\n   *\n   * @param hilbertCfg\n   * @return {*}\n   */\n  static validateHilbertCfg(hilbertCfg) {\n    const ajv = new Ajv();\n    if (!ajv.validate(HilbertCfgSchema, hilbertCfg)) {\n      throw new Error(`Error in Hilbert CFG: ${ajv.errorsText()}`);\n    }\n    return hilbertCfg;\n  }\n}\n"],"sourceRoot":"/source/"}