{"version":3,"sources":["lib/station-manager.js"],"names":["Promise","require","EventEmitter","Ajv","HilbertCfgSchema","StationManager","nconf","logger","hilbertCLI","mkLivestatus","events","logEntries","lastLogID","globalHilbertCLIOutputBuffer","lastMKLivestatusDump","clearStations","loadHilbertCfg","then","pollLoopBody","pollDelay","get","consecutiveErrors","errorDigestSize","pollMKLivestatus","setTimeout","catch","error","signalUpdate","getHilbertCfg","validateHilbertCfg","hilbertCfg","Object","entries","Stations","stationID","stationCFG","hidden","addStation","ajv","validate","Error","errorsText","aStation","verbose","id","stationList","push","stationIndex","set","i","indexOf","splice","delete","Map","stationIDs","eligibleStations","station","getStationByID","setQueuedToStartState","map","eligibleStation","setStartingState","startStation","outputBuffer","log","setErrorState","concurrency","setQueuedToStopState","setStoppingState","stopStation","appID","setQueuedToChangeAppState","setChangingAppState","changeApp","type","message","newLogEntry","time","Date","toISOString","station_id","station_name","name","maxEntries","length","slice","getState","allStationsStatus","lastState","changes","stationStatus","updateFromMKLivestatus","emit"],"mappings":"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","file":"lib/station-manager.js","sourcesContent":["const Promise = require('bluebird');\nconst EventEmitter = require('events').EventEmitter;\nconst Ajv = require('ajv');\n\nconst HilbertCfgSchema = require('../../data/schema/hilbert-cfg-partial.json');\n\nimport Station from './station';\nimport TerminalOutputBuffer from './terminal-output-buffer';\n\n/**\n * Service Layer for hilbert\n * Dispatches requests asynchronously and keeps cached state\n */\nexport default class StationManager {\n\n  /**\n   * Create a Station Manager\n   *\n   * @param {Object} nconf - Instance of nconf configuration\n   * @param {Object} logger - Instance of winston logger\n   * @param {HilbertCLIConnector} hilbertCLI - hilbert-cli connector\n   * @param {MKLivestatusConnector} mkLivestatus - MKLivestatus connector\n   */\n  constructor(nconf, logger, hilbertCLI, mkLivestatus) {\n    this.nconf = nconf;\n    this.logger = logger;\n\n    this.hilbertCLI = hilbertCLI;\n    this.mkLivestatus = mkLivestatus;\n\n    this.events = new EventEmitter();\n    this.logEntries = [];\n    this.lastLogID = 1;\n\n    this.globalHilbertCLIOutputBuffer = new TerminalOutputBuffer();\n    this.lastMKLivestatusDump = [];\n\n    this.clearStations();\n  }\n\n  /**\n   * Reads the station configuration and begins polling station status\n   *\n   * @return {Promise}\n   */\n  init() {\n    return this.loadHilbertCfg().then(() => {\n      const pollLoopBody = () => {\n        const pollDelay = this.nconf.get('mkls_poll_delay');\n        let consecutiveErrors = 0;\n        const errorDigestSize = 50;\n        this.pollMKLivestatus().then(() => {\n          consecutiveErrors = 0;\n          setTimeout(pollLoopBody, pollDelay);\n        }).catch(() => {\n          if (consecutiveErrors % errorDigestSize) {\n            if (consecutiveErrors !== 0) {\n              this.logger.error(\n                `Station manager: Repeated MKLivestatus polling errors (${errorDigestSize} times)`);\n            }\n          }\n          consecutiveErrors++;\n          setTimeout(pollLoopBody, pollDelay);\n        });\n      };\n      pollLoopBody();\n    });\n  }\n\n  /**\n   * Loads the station configuration.\n   *\n   * If the configuration was already loaded this method clears it\n   * and reloads everything\n   *\n   * @returns {Promise}\n   */\n  loadHilbertCfg() {\n    this.clearStations();\n    this.signalUpdate();\n\n    return this.hilbertCLI.getHilbertCfg(this.globalHilbertCLIOutputBuffer)\n      .then(hilbertCfg => this.validateHilbertCfg(hilbertCfg))\n      .then((hilbertCfg) => {\n        for (const [stationID, stationCFG] of Object.entries(hilbertCfg.Stations)) {\n          if (!stationCFG.hidden) {\n            this.addStation(new Station(stationID, stationCFG));\n          }\n        }\n        this.signalUpdate();\n      });\n  }\n\n  /**\n   * Validates a hilbert configuration according to the schema\n   *\n   * Only the parts of the configuration used by this program are validated\n   *\n   * @param hilbertCfg\n   * @return {*}\n   */\n  validateHilbertCfg(hilbertCfg) {\n    const ajv = new Ajv();\n    if (!ajv.validate(HilbertCfgSchema, hilbertCfg)) {\n      throw new Error(`Error in Hilbert CFG: ${ajv.errorsText()}`);\n    }\n    return hilbertCfg;\n  }\n\n  /**\n   * Adds a station to the manager\n   * @param {Station} aStation\n   */\n  addStation(aStation) {\n    this.logger.verbose(`Station manager: Adding station ${aStation.id}`);\n    this.stationList.push(aStation);\n    this.stationIndex.set(aStation.id, aStation);\n  }\n\n  /**\n   * Removes a station from the manager\n   * @param {Station} aStation\n   */\n  removeStation(aStation) {\n    this.logger.verbose(`Station manager: Removing station ${aStation.id}`);\n    const i = this.stationList.indexOf(aStation);\n    if (i !== -1) {\n      this.stationList.splice(i, 1);\n    }\n\n    this.stationIndex.delete(aStation.id);\n  }\n\n  /**\n   * Removes all the stations\n   */\n  clearStations() {\n    this.logger.verbose('Station manager: Clearing all stations');\n    this.stationIndex = new Map();\n    this.stationList = [];\n  }\n\n  /**\n   * Get the ordered list of stations\n   * @returns {Array}\n   */\n  getStations() {\n    return this.stationList;\n  }\n\n  /**\n   * Return a station identified by ID\n   *\n   * @param {string} id - Station ID\n   * @returns {Station}\n   */\n  getStationByID(id) {\n    return this.stationIndex.get(id);\n  }\n\n  /**\n   * Start indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations to start\n   * @return {Promise}\n   */\n  startStations(stationIDs) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToStartState()) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(`Station manager: Starting station ${eligibleStation}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setStartingState();\n        this.signalUpdate();\n        return this.hilbertCLI.startStation(station.id, station.outputBuffer).then(() => {\n          this.logger.verbose(`Station manager: Station ${eligibleStation} started`);\n          this.log('message', station, 'Station started');\n        })\n        .catch(() => {\n          this.logger.verbose(`Station manager: Station ${eligibleStation} failed to start`);\n          this.log('error', station, 'Error starting station');\n          station.setErrorState('Failure starting the station');\n        })\n        .then(() => {\n          this.signalUpdate();\n        });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Stop indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations to stop\n   * @return {Promise}\n   */\n  stopStations(stationIDs) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToStopState()) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(`Station manager: Stopping station ${eligibleStation}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setStoppingState();\n        this.signalUpdate();\n        return this.hilbertCLI.stopStation(station.id, station.outputBuffer).then(() => {\n          this.logger.verbose(`Station manager: Station ${eligibleStation} stopped`);\n          this.log('message', station, 'Station stopped');\n        })\n          .catch(() => {\n            this.logger.verbose(`Station manager: Station ${eligibleStation} failed to stop`);\n            this.log('error', station, 'Error stopping station');\n            station.setErrorState('Failure stopping the station');\n          })\n          .then(() => {\n            this.signalUpdate();\n          });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Change the application running in indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations in which to change the appID\n   * @param {string} appID - Name of the appID to run\n   * @return {Promise}\n   */\n  changeApp(stationIDs, appID) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToChangeAppState(appID)) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(\n          `Station manager: Changing app of station ${eligibleStation} to ${appID}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setChangingAppState(appID);\n        this.signalUpdate();\n        return this.hilbertCLI.changeApp(eligibleStation, appID, station.outputBuffer).then(() => {\n          this.logger.verbose(\n            `Station manager: Changed app of station ${eligibleStation} to ${appID}`);\n          this.log('message', station, `Launched app ${appID}`);\n        })\n        .catch(() => {\n          this.logger.verbose(\n            `Station manager: Failed changing app of station ${eligibleStation} to ${appID}`);\n          this.log('error', station, `Failed to launch app ${appID}`);\n          station.setErrorState(`Failed to open ${appID}`);\n        })\n        .then(() => {\n          this.signalUpdate();\n        });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Return the station activity log\n   *\n   * Each log entry is an object with the following structure:\n   * - id {string} : Unique id of the entry\n   * - time {string} : Timestamp in ISO format\n   * - type {string} : info | warning | error\n   * - message {string} : Event description\n   *\n   * @returns {Array}\n   */\n  getLog() {\n    return this.logEntries;\n  }\n\n\n  /**\n   * Logs an event\n   *\n   * @param {string} type - Event type: info | warning | error\n   * @param {Station|null} station - station associated with the event logged\n   * @param {string} message - Message to log\n   */\n  log(type, station, message) {\n    const newLogEntry = {\n      id: this.lastLogID,\n      time: new Date().toISOString(),\n      type,\n      message,\n    };\n\n    if (station !== null) {\n      newLogEntry.station_id = station.id;\n      newLogEntry.station_name = station.name;\n    }\n\n    this.lastLogID++;\n    this.logEntries.push(newLogEntry);\n\n    const maxEntries = this.nconf.get('max_log_length');\n    if (this.logEntries.length > maxEntries) {\n      this.logEntries = this.logEntries.slice(this.logEntries.length - maxEntries);\n    }\n  }\n\n  /**\n   * Polls MKLivestatus and updates the state of stations\n   * @returns {Promise}\n   */\n  pollMKLivestatus() {\n    return this.mkLivestatus.getState().then((allStationsStatus) => {\n      const lastState = [];\n      let changes = false;\n      for (const stationStatus of allStationsStatus) {\n        lastState.push(stationStatus);\n        const station = this.getStationByID(stationStatus.id);\n        if (station) {\n          if (station.updateFromMKLivestatus(stationStatus)) {\n            changes = true;\n          }\n        }\n      }\n      this.lastMKLivestatusDump = lastState;\n\n      if (changes) {\n        this.signalUpdate();\n      }\n    });\n  }\n  /**\n   * Signal listeners that station data was modified\n   * @private\n   */\n  signalUpdate() {\n    this.events.emit('stationUpdate');\n  }\n}\n"],"sourceRoot":"/source/"}