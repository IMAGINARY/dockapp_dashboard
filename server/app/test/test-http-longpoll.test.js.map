{"version":3,"sources":["test/test-http-longpoll.test.js"],"names":["logger","require","nconf","request","describe","apiServer","httpServer","stationManager","pollWaited","pollTimedOut","beforeEach","done","defaults","port","hilbert_cli_path","test","scriptConcurrency","max_log_length","log_directory","log_level","mkls_poll_delay","mkls_cmd","long_poll_timeout","db_path","testBackend","addStation","id","name","type","default_app","possible_apps","getHilbertCLIConnector","getMKLivestatusConnector","init","then","getServer","events","on","it","get","query","lastUpdateID","set","expect","err","res","should","equal","body","updateID","be","above","startStations","responseIsEmpty","Object","keys","length","constructor"],"mappings":"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","file":"test/test-http-longpoll.test.js","sourcesContent":["import StationManager from '../lib/station-manager';\nimport HttpAPIServer from '../lib/http-api-server';\nimport TestBackend from '../lib/test-backend';\n\nconst logger = require('winston');\nconst nconf = require('nconf');\nconst request = require('supertest');\nrequire('should');\n\ndescribe('HTTP Longpoll', () => {\n  let apiServer = null;\n  let httpServer = null;\n  let stationManager = null;\n\n  let pollWaited = false;\n  let pollTimedOut = false;\n\n  beforeEach((done) => {\n    nconf.defaults({\n      port: '3000',\n      hilbert_cli_path: '../work/dockapp',\n      test: true,\n      scriptConcurrency: 20,\n      max_log_length: 100,\n      log_directory: './log',\n      log_level: 'info', // error, warn, info, verbose, debug, silly\n      mkls_poll_delay: 1000,\n      mkls_cmd: 'nc localhost 6557',\n      long_poll_timeout: 0,\n      db_path: '',\n    });\n\n    const testBackend = new TestBackend(nconf, logger);\n    testBackend.addStation({\n      id: 'station_a',\n      name: 'Station A',\n      type: 'type_a',\n      default_app: 'app_a',\n      possible_apps: ['app_a', 'app_b', 'app_c'],\n    });\n\n    stationManager = new StationManager(\n      nconf,\n      logger,\n      testBackend.getHilbertCLIConnector(),\n      testBackend.getMKLivestatusConnector()\n    );\n\n    stationManager.init().then(() => {\n      apiServer = new HttpAPIServer(stationManager, nconf, logger);\n      apiServer.init().then(() => {\n        httpServer = apiServer.getServer();\n\n        pollWaited = false;\n        pollTimedOut = false;\n\n        apiServer.events.on('longPollWait', () => {\n          pollWaited = true;\n        });\n\n        apiServer.events.on('longPollTimeout', () => {\n          pollTimedOut = true;\n        });\n\n        done();\n      });\n    });\n  });\n\n  it('Responds immediately if out of sync', (done) => {\n    request(httpServer)\n      .get('/stations')\n      .query({ lastUpdateID: 0 })\n      .set('Accept', 'application/json')\n      .expect('Content-Type', /json/)\n      .expect(200, (err, res) => {\n        pollWaited.should.equal(false);\n        pollTimedOut.should.equal(false);\n        res.body.updateID.should.equal(1);\n        done();\n      });\n  });\n\n  it('Responds after an update if synced', (done) => {\n    request(httpServer)\n      .get('/stations')\n      .query({ lastUpdateID: 1 })\n      .set('Accept', 'application/json')\n      .expect('Content-Type', /json/)\n      .expect(200, (err, res) => {\n        // Response arrives after update\n        pollWaited.should.equal(true);\n        pollTimedOut.should.equal(false);\n        res.body.updateID.should.be.above(1);\n        done();\n      });\n\n    apiServer.events.on('longPollWait', () => {\n      // Simulate an update after it begins the wait\n      stationManager.startStations(['station_a']);\n    });\n  });\n\n  it('Responds (empty response) if synced and times-out waiting for an update', (done) => {\n    request(httpServer)\n      .get('/stations')\n      .query({ lastUpdateID: 1 })\n      .set('Accept', 'application/json')\n      .expect('Content-Type', /json/)\n      .expect(200, (err, res) => {\n        // Response arrives after time out\n        pollWaited.should.equal(true);\n        pollTimedOut.should.equal(true);\n\n        // Response should be empty\n        const responseIsEmpty = (Object.keys(res.body).length === 0 &&\n          res.body.constructor === Object);\n        responseIsEmpty.should.equal(true);\n        done();\n      });\n  });\n});\n"],"sourceRoot":"/source/"}