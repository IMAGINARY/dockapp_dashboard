{"version":3,"sources":["main.js"],"names":["appPackage","require","logger","nconf","express","app","bodyParser","EventEmitter","iconmap","use","json","env","argv","file","defaults","port","hilbert_cli_path","test","scriptConcurrency","max_log_length","log_directory","log_level","mkls_poll_delay","mkls_cmd","add","transports","File","filename","get","level","handleExceptions","process","on","err","error","message","exitCode","info","version","hilbertCLIConnector","mkLivestatusConnector","testBackend","getHilbertCLIConnector","getMKLivestatusConnector","stationManager","init","then","catch","exit","getIconURL","appID","undefined","pollUpdateEmitter","setMaxListeners","updateID","pollTimeoutDelay","respondJSON","res","data","writeHead","end","JSON","stringify","stationDataResponse","stations","getStations","station","icon","emptyResponse","req","Number","query","lastSeen","pollTimeout","setTimeout","emit","once","clearTimeout","events","post","body","action","debug","stationIDs","startStations","stopStations","changeApp","outputBuffer","hasOwnProperty","stationID","getStationByID","globalHilbertCLIOutputBuffer","lines","getAll","lastState","lastMKLivestatusDump","entries","getLog","listen"],"mappings":"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","file":"main.js","sourcesContent":["import 'babel-polyfill';\n\nconst appPackage = require('../package.json');\nconst logger = require('winston');\nconst nconf = require('nconf');\nconst express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst EventEmitter = require('events').EventEmitter;\n\nimport StationManager from './lib/station-manager';\nimport HilbertCLIConnector from './lib/hilbert-cli-connector';\nimport MKLivestatusConnector from './lib/mk-livestatus-connector';\nimport TestBackend from './lib/test-backend';\n\nconst iconmap = require('../iconmap.json');\n\napp.use(bodyParser.json());\n\nnconf.env().argv();\nnconf.file('config.json');\nnconf.defaults({\n  port: '3000',\n  hilbert_cli_path: '../work/dockapp',\n  test: false,\n  scriptConcurrency: 20,\n  max_log_length: 100,\n  log_directory: './log',\n  log_level: 'info', // error, warn, info, verbose, debug, silly\n  mkls_poll_delay: 1000,\n  mkls_cmd: 'nc localhost 6557',\n});\n\nlogger.add(logger.transports.File, {\n  filename: `${nconf.get('log_directory')}/hilbert-ui.log`,\n  level: nconf.get('log_level'),\n  handleExceptions: true,\n  json: false,\n});\n\nlogger.level = nconf.get('log_level');\n\nprocess.on('uncaughtException', (err) => {\n  logger.error(`Uncaught exception: ${err.message}. Exiting process.`);\n  process.exitCode = 1;\n});\n\nlogger.info(`Starting hilbert-ui server (v${appPackage.version})`);\n\nlet hilbertCLIConnector = null;\nlet mkLivestatusConnector = null;\n\nif (nconf.get('test')) {\n  logger.info('Running in Test Mode');\n  const testBackend = new TestBackend(nconf, logger);\n  hilbertCLIConnector = testBackend.getHilbertCLIConnector();\n  mkLivestatusConnector = testBackend.getMKLivestatusConnector();\n} else {\n  hilbertCLIConnector = new HilbertCLIConnector(nconf, logger);\n  mkLivestatusConnector = new MKLivestatusConnector(nconf, logger);\n}\n\nconst stationManager = new StationManager(nconf, logger, hilbertCLIConnector, mkLivestatusConnector);\nstationManager.init().then(() => {\n\n}).catch((err) => {\n  logger.error(`Error initializing Station Manager: ${err.message}. Exiting process.`);\n  process.exit(1);\n});\n\n/**\n * Return the URL of the icon of the specified app\n *\n * @param {string} appID - ID of the app\n * @returns {string} - URL of the icon\n */\nfunction getIconURL(appID) {\n  if (iconmap[appID] !== undefined) {\n    return `icons/${iconmap[appID]}`;\n  }\n  return 'icons/none.png';\n}\n\n// Longpoll begin\n\nconst pollUpdateEmitter = new EventEmitter();\npollUpdateEmitter.setMaxListeners(100);\nlet updateID = 1;\nconst pollTimeoutDelay = 15000;\n\nfunction respondJSON(res, data) {\n  res.writeHead(200, { 'Content-Type': 'application/json' });\n  res.end(JSON.stringify(data));\n}\n\nfunction stationDataResponse() {\n  const stations = stationManager.getStations();\n  for (const station of stations) {\n    station.icon = getIconURL(station.app);\n  }\n\n  return {\n    updateID,\n    stations,\n  };\n}\n\nfunction emptyResponse() {\n  return {};\n}\n\napp.get('/poll.json', (req, res) => {\n  // if the client is out of sync respond immediately\n  if (Number(req.query.lastSeen) !== updateID) {\n    respondJSON(res, stationDataResponse());\n  } else {\n    // ... otherwise wait for an updateFromMKLivestatus to respond\n\n    // On timeout send an empty updateFromMKLivestatus\n    const pollTimeout = setTimeout(() => {\n      pollUpdateEmitter.emit('updateFromMKLivestatus', emptyResponse());\n    }, pollTimeoutDelay);\n\n    // If there was an updateFromMKLivestatus respond\n    pollUpdateEmitter.once('updateFromMKLivestatus', (data) => {\n      clearTimeout(pollTimeout);\n      respondJSON(res, data);\n    });\n  }\n});\n\nstationManager.events.on('stationUpdate', () => {\n  updateID++;\n  pollUpdateEmitter.emit('updateFromMKLivestatus', stationDataResponse());\n});\n\n// Longpoll end\n\napp.get('/stations.json', (req, res) => {\n  respondJSON(res, stationDataResponse());\n});\n\napp.post('/stations.json', (req, res) => {\n  if (req.body.action === 'start') {\n    logger.debug(`HTTP request received: Start stations ${req.body.stationIDs}`);\n    stationManager.startStations(req.body.stationIDs);\n    respondJSON(res, emptyResponse());\n  } else if (req.body.action === 'stop') {\n    logger.debug(`HTTP request received: Stop stations ${req.body.stationIDs}`);\n    stationManager.stopStations(req.body.stationIDs);\n    respondJSON(res, emptyResponse());\n  } else if (req.body.action === 'change_app') {\n    logger.debug(\n      `HTTP request received: Change app of stations ${req.body.stationIDs} to ${req.body.app}`);\n    stationManager.changeApp(req.body.stationIDs, req.body.app);\n    respondJSON(res, emptyResponse());\n  } else {\n    logger.error(`HTTP request received: Invalid POST request with action ${req.body.action}`);\n    res.writeHead(404, 'Action not found');\n    res.end();\n  }\n});\n\napp.get('/station_output.json', (req, res) => {\n  let outputBuffer = null;\n  if (req.query.hasOwnProperty('stationID')) {\n    logger.debug(`HTTP request received: Get output of station ${req.query.stationID}`);\n    const station = stationManager.getStationByID(req.query.stationID);\n    if (station) {\n      outputBuffer = station.outputBuffer;\n    }\n  } else {\n    logger.debug('HTTP request received: Get global terminal output');\n    outputBuffer = stationManager.globalHilbertCLIOutputBuffer;\n  }\n\n  if (outputBuffer) {\n    respondJSON(res, {\n      lines: outputBuffer.getAll(),\n    });\n  } else {\n    logger.error(`Requested output of non existant station ${req.query.stationID}`);\n    res.writeHead(404, 'Station not found');\n    res.end();\n  }\n});\n\napp.get('/mklivestatus.json', (req, res) => {\n  logger.debug('HTTP request received: Get last MKLivestatus state');\n  respondJSON(res, {\n    lastState: stationManager.lastMKLivestatusDump,\n  });\n});\n\napp.get('/log.json', (req, res) => {\n  logger.debug('HTTP request received: Get log');\n  respondJSON(res, { entries: stationManager.getLog() });\n});\n\n// Spawn server\nconst port = nconf.get('port');\napp.listen(port);\nlogger.info(`Server listening on port ${port}.`);\n\n"],"sourceRoot":"/source/"}