// Compiled by Babel
// ** DO NOT EDIT THIS FILE DIRECTLY **
//
'use strict';

require('babel-polyfill');

var _stationManager = require('./lib/station-manager');

var _stationManager2 = _interopRequireDefault(_stationManager);

var _dockappConnector = require('./lib/dockapp-connector');

var _dockappConnector2 = _interopRequireDefault(_dockappConnector);

var _mkLivestatusConnector = require('./lib/mk-livestatus-connector');

var _mkLivestatusConnector2 = _interopRequireDefault(_mkLivestatusConnector);

var _testBackend = require('./lib/test-backend');

var _testBackend2 = _interopRequireDefault(_testBackend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var appPackage = require('../package.json');
var logger = require('winston');
var nconf = require('nconf');
var express = require('express');
var app = express();
var bodyParser = require('body-parser');
var EventEmitter = require('events').EventEmitter;

var iconmap = require('../iconmap.json');

app.use(bodyParser.json());

nconf.env().argv();
nconf.file('config.json');
nconf.defaults({
  port: '3000',
  dockapp_path: '../work/dockapp',
  test: false,
  scriptConcurrency: 20,
  max_log_length: 100,
  log_directory: './log',
  log_level: 'info', // error, warn, info, verbose, debug, silly
  mkls_poll_delay: 1000,
  mkls_cmd: 'nc localhost 6557'
});

logger.add(logger.transports.File, {
  filename: nconf.get('log_directory') + '/dockapp_dashboard.log',
  level: nconf.get('log_level'),
  handleExceptions: true,
  json: false
});

logger.level = nconf.get('log_level');

process.on('uncaughtException', function (err) {
  logger.error('Uncaught exception: ' + err.message + '. Exiting process.');
  process.exitCode = 1;
});

logger.info('Starting dockapp_dashboard server (v' + appPackage.version + ')');

var dockAppConnector = null;
var mkLivestatusConnector = null;

if (nconf.get('test')) {
  logger.info('Running in Test Mode');
  var testBackend = new _testBackend2.default(nconf, logger);
  dockAppConnector = testBackend.getDockappConnector();
  mkLivestatusConnector = testBackend.getMKLivestatusConnector();
} else {
  dockAppConnector = new _dockappConnector2.default(nconf, logger);
  mkLivestatusConnector = new _mkLivestatusConnector2.default(nconf, logger);
}

var stationManager = new _stationManager2.default(nconf, logger, dockAppConnector, mkLivestatusConnector);
stationManager.init().then(function () {}).catch(function (err) {
  logger.error('Error initializing Station Manager: ' + err.message + '. Exiting process.');
  process.exit(1);
});

/**
 * Return the URL of the icon of the specified app
 *
 * @param {string} appID - ID of the app
 * @returns {string} - URL of the icon
 */
function getIconURL(appID) {
  if (iconmap[appID] !== undefined) {
    return 'icons/' + iconmap[appID];
  }
  return 'icons/none.png';
}

// Longpoll begin

var pollUpdateEmitter = new EventEmitter();
pollUpdateEmitter.setMaxListeners(100);
var updateID = 1;
var pollTimeoutDelay = 15000;

function respondJSON(res, data) {
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify(data));
}

function stationDataResponse() {
  var stations = stationManager.getStations();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = stations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var station = _step.value;

      station.icon = getIconURL(station.app);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return {
    updateID: updateID,
    stations: stations
  };
}

function emptyResponse() {
  return {};
}

app.get('/poll.json', function (req, res) {
  // if the client is out of sync respond immediately
  if (Number(req.query.lastSeen) !== updateID) {
    respondJSON(res, stationDataResponse());
  } else {
    (function () {
      // ... otherwise wait for an updateFromMKLivestatus to respond

      // On timeout send an empty updateFromMKLivestatus
      var pollTimeout = setTimeout(function () {
        pollUpdateEmitter.emit('updateFromMKLivestatus', emptyResponse());
      }, pollTimeoutDelay);

      // If there was an updateFromMKLivestatus respond
      pollUpdateEmitter.once('updateFromMKLivestatus', function (data) {
        clearTimeout(pollTimeout);
        respondJSON(res, data);
      });
    })();
  }
});

stationManager.events.on('stationUpdate', function () {
  updateID++;
  pollUpdateEmitter.emit('updateFromMKLivestatus', stationDataResponse());
});

// Longpoll end

app.get('/stations.json', function (req, res) {
  respondJSON(res, stationDataResponse());
});

app.post('/stations.json', function (req, res) {
  if (req.body.action === 'start') {
    logger.debug('HTTP request received: Start stations ' + req.body.stationIDs);
    stationManager.startStations(req.body.stationIDs);
    respondJSON(res, emptyResponse());
  } else if (req.body.action === 'stop') {
    logger.debug('HTTP request received: Stop stations ' + req.body.stationIDs);
    stationManager.stopStations(req.body.stationIDs);
    respondJSON(res, emptyResponse());
  } else if (req.body.action === 'change_app') {
    logger.debug('HTTP request received: Change app of stations ' + req.body.stationIDs + ' to ' + req.body.app);
    stationManager.changeApp(req.body.stationIDs, req.body.app);
    respondJSON(res, emptyResponse());
  } else {
    logger.error('HTTP request received: Invalid POST request with action ' + req.body.action);
    res.writeHead(404, 'Action not found');
    res.end();
  }
});

app.get('/station_output.json', function (req, res) {
  var outputBuffer = null;
  if (req.query.hasOwnProperty('stationID')) {
    logger.debug('HTTP request received: Get output of station ' + req.query.stationID);
    var station = stationManager.getStationByID(req.query.stationID);
    if (station) {
      outputBuffer = station.outputBuffer;
    }
  } else {
    logger.debug('HTTP request received: Get global terminal output');
    outputBuffer = stationManager.globalDockAppOutputBuffer;
  }

  if (outputBuffer) {
    respondJSON(res, {
      lines: outputBuffer.getAll()
    });
  } else {
    logger.error('Requested output of non existant station ' + req.query.stationID);
    res.writeHead(404, 'Station not found');
    res.end();
  }
});

app.get('/mklivestatus.json', function (req, res) {
  logger.debug('HTTP request received: Get last MKLivestatus state');
  respondJSON(res, {
    lastState: stationManager.lastMKLivestatusDump
  });
});

app.get('/log.json', function (req, res) {
  logger.debug('HTTP request received: Get log');
  respondJSON(res, { entries: stationManager.getLog() });
});

// Spawn server
var port = nconf.get('port');
app.listen(port);
logger.info('Server listening on port ' + port + '.');
//# sourceMappingURL=main.js.map
